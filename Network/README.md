# Network

1. [OSI 7계층](#osi-7계층)
   * [물리 계층 (Physical Layer)](#물리-계층-physical-layer)
   * [데이터 링크 계층 (Data Link Layer)](#데이터-링크-계층-data-link-layer)
   * [네트워크 계층 (Network Layer)](#네트워크-계층-network-layer)
   * [전송 계층 (Transport Layer)](#전송-계층-transport-layer)
   * [세션 계층 (Session Layer)](#세션-계층-session-layer)
   * [표현 계층 (Presentation Layer)](#표현-계층-presentation-layer)
   * [응용 계층 (Application Layer)](#응용-계층-application-layer)
2. [Data Fragmentation(+Segmentation)(단편화)(분할) / Reassembly(병합)(재조립)(재결합) 이란?](#data-fragmentationsegmentation단편화분할--reassembly병합재조립재결합-이란)
3. [TCP/IP 모델](#tcpip-모델)
4. [TCP와 UDP](#tcp와-udp)
   * [TCP](#tcp)
   * [UDP](#udp)
   * [TCP, UDP 공통점](#tcp-udp-공통점)
   * [TCP, UDP 차이점](#tcp-udp-차이점)
   * [TCP 관련 질문](#tcp-관련-질문)
5. [HTTP와 HTTPS](#http와-https)
   * [HTTP란?](#http란)
   * [HTTPS란?](#https란)
   * [HTTP와 HTTPS](#http와-https)
   * [HTTP/1.1과 HTTP/2.0](#http11과-http20)
6. [GET과 POST](#get과-post)
   * [GET 방식](#get-방식)
   * [POST 방식](#post-방식)
   * [GET vs POST 비교](#get-vs-post-비교)
7. [쿠키와 세션](#쿠키와-세션)
   * [쿠키](#쿠키)
   * [세션](#세션)
   * [쿠키와 세션의 차이점](#쿠키와-세션의-차이점)
8. [DNS](#dns)
   * [DNS란?](#dns란)
   * [DNS 프로세스](#dns-프로세스)
   * [작동원리](#작동원리)
9. [REST, REST API, RESTful](#rest-rest-api-restful)
   * [REST (Representational State Transfer)](#rest-representational-state-transfer)
   * [REST API](#rest-api)
   * [RESTful](#restful)
10. [SOCKET](#socket)
   * [SOCKET이란?](#socket이란)
   * [종류](#종류)
   * [HTTP 통신과 SOCKET 통신의 비교](#http-통신과-socket-통신의-비교)
11. [기타 질문](#기타-질문)


## OSI 7계층

국제 표준화 기구(ISO)에서 개발한 모델으로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것이다.

* 프로토콜을 기능별로 나눈 모델
* 각 계층은 하위 계층의 기능만을 이용하고, 상위 계층에게 기능을 제공한다.

**:heavy_plus_sign: 왜 계층을 나누게 되었을까?**

계층을 분리함으로써 각 계층은 독립적인 역할을 할 수 있다. 역할이 분리되면서 문제가 발생했을 때 현상을 보고 어떤 계층에서 문제가 생겼는지 파악 가능하다. (각 계층의 수행 역할이 다르기 때문에 가능)

<img src="https://user-images.githubusercontent.com/33208360/116966836-fd2fea80-aceb-11eb-98f6-97f590d45b53.png" alt="image" style="zoom: 67%;" />

### 물리 계층 (Physical Layer)

* 네트워크의 기본 네트워크 하드웨어 전송 기술을 이룬다.

* 전기적인, 기계적인 신호를 주고 받는 역할을 하는 계층이다.

* 이 계층에 속하는 대표적인 장비는 통신 케이블, 허브, 리피터 등이 있다.

* 데이터의 종류나 오류를 제어하지 않는다. 이는 다음 계층인 데이터 링크 계층에서 다룬다.
* 전송 단위는 Bit이다.

### 데이터 링크 계층 (Data Link Layer)

* Point to Point 간의 신뢰성있는 전송을 보장하기 위한 계층이다. 전송 데이터에 대한 CRC 오류 제어와 흐름 제어가 필요하다. (CRC: 순환 중복 검사, 여러 개의 bit 오류 수정)

* 주소 값은 물리적으로 할당받는데, 이는 네트워크 카드가 만들어질 때부터 MAC 주소가 정해져 있다는 뜻이다. 물리 주소인 MAC 주소가 이 계층에 해당한다.

* 대표적인 장비는 스위치와 브릿지가 있다.

* 데이터 링크 계층의 가장 잘 알려진 예는 *이더넷* 이다.

* 데이터 전송 단위는 Frame이다.

### 네트워크 계층 (Network Layer)

* 여러 개의 노드를 거칠 때마다 경로를 찾아주는 역할을 하는 계층으로 다양한 길이의 데이터를 네트워크들을 통해 전달하고, 그 과정에서 전송 계층이 요구하는 서비스 품질(QoS)을 제공하기 위한 기능적, 절차적 수단을 제공한다.

* 라우팅, 흐름 제어, 프래그멘테이션(Fragmentation), 오류 제어, 인터네트워킹(InterNetworking) 등을 수행한다.
* 논리적인 주소 구조(IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며, 계층적이다.
* 데이터 전송 단위는 Datagram(Packet)이다.

### 전송 계층 (Transport Layer)

* 양 끝단(End to end)의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.

* 시퀀스 넘버 기반의 오류 제어 방식을 사용한다.

* 세그멘테이션을 한다.

* 전송 계층은 특정 연결의 유효성을 제어하고, 일부 프로토콜은 상태 개념이 있고(Stateful), 연결 기반(connection oriented)이다.

  (=> 전송 계층이 패킷들의 전송이 유효한지 확인하고, 전송 실패한 패킷들을 다시 전송한다는 것)

* 가장 잘 알려진 전송 계층의 예는 TCP, UDP이다.

* 데이터 전송 단위는 Segment이다.

### 세션 계층 (Session Layer)

* 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.
* 동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full Duplex)의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행한다.
* TCP/IP 세션을 만들고 없애는 책임을 진다.

### 표현 계층 (Presentation Layer)

* 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용계층으로부터 덜어 준다.
* MIME 인코딩이나 암호화 등의 동작이 이 계층에서 이루어진다.

### 응용 계층 (Application Layer)

* 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.
* 일반적인 응용 서비스는 관련된 응용 프로세스들 사이의 전환을 제공한다.

## Data Fragmentation(+Segmentation)(단편화)(분할) / Reassembly(병합)(재조립)(재결합) 이란?

> https://blog.naver.com/sung_mk1919/221435640417

★TCP와 UDP 일 때 분할되는 시기, 위치가 다릅니다. ★

### Segmentation / Fragmentation

데이터의 사이즈가 (기존 MTU 기준보다) 큰 사이즈일 시 L3, L2에서 데이터를 수용하기 위해서 거대한 데이터를 MTU 단위로 분할합니다. 이를 Segmentation / Fragmentation이라고 합니다. 혹은 단편화라고도 부릅니다. 쉽게 분할로 부르겠습니다.

(Segmentation 항목을 추가된 이유는 분할하는 개념은 Fragmentation과 같지만 프로토콜 종류에 따라 수행되는 위치와 이름이 달라지기 때문에 추가되었습니다.)

​Segmentation 같은 경우는 TCP 프로토콜을 이용한 통신일 때 사용되는 분할로서 분할된 데이터는 Segment로 불리며 이 작업은 4계층 프로토콜 자체에서 수행됩니다. Fragmentation은 UDP 프로토콜을 이용한 통신일 때 사용되는 분할로서 분할된 데이터는 Packet으로 불리며 이 작업은 3계층 프로토콜 자체에서 수행됩니다. 라우터도 3계층 밖에 존재하지 않기 때문에 3계층에서 Fragmentation가 일어날 수 있습니다. TCP의 통신일 경우는 송신 장비가 상대 장비의 MTU와 비교해 상대측의 MTU가 낮으면 상대 장비의 MTU로 맞춥니다. 또한, 상대 장비뿐만 아니라 TCP 3way-handshaking을 할 때 경로에 있는 라우터들의 MTU 탐색을 한 뒤에 추후 라우터에서 분할을 시도합니다. (신뢰성 통신의 근거) 그러나 UDP의 통신일 경우는 상대 장비의 MTU를 고려하지 않고 송신하기 때문에 빠르지만 불안정하며 언제든지 데이터 전송 실패로 이어질 수 있습니다. 또한, 데이터를 그대로 3계층에 보내고 3계층에서 경로 MTU탐색을 한 뒤에 추후 라우터에서 분할 및 전송을 합니다.

### Reassembly

데이터의 사이즈가 (기존 MTU 기준보다) 큰 사이즈일 시 L3, L2에서 데이터를 수용하기 위해서 데이터를 Fragmentation한 상태로 보냅니다. 이 분할된 데이터를 그대로 수용할 수 없고 다시 Reassembly (편의상 재조립으로 부르겠습니다.) 하여 완성된 데이터를 상대방이 그대로 수용합니다. 이는 3, 4계층 그리고 라우터에서

일어나며 (UDP는 3계층에서 재조립됩니다.) 분할되서 온 데이터들을 분할 시 TCP 헤더에 부여된 Sequence Number를 기준으로 재조립을 합니다. (UDP는 단방향 프로토콜로 비연결지향 프로토콜입니다. 구조에도 확인할 수 있듯이 Sequence Number가 없습니다. 보낸 후의 뒷일은 생각하지 않는다고 보시면 됩니다.)

### 요약

TCP 프로토콜을 이용한 통신을 할 때, 데이터를 Segment로 분할하여 만드는 과정을 Segmentation이라고 합니다.

이는 송신 장비의 4계층 전송 계층에서 이루어집니다.

UDP 프로토콜을 이용한 통신을 할 때, 데이터를 Packet으로 분할하여 만드는 과정을 Fragmentation이라고 합니다.

이는 송신 장비의 3계층 인터넷 계층에서 이루어집니다.

TCP/UDP 프로토콜과 무관하게 라우터(송신 장비와 다른 장비)에서​ 이전 장비에서 받는 Packet이 클 때,

더 작은 Packet으로 분할하여 만드는 과정을 Fragmentation이라고 합니다.



즉, TCP 프로토콜을 이용한 통신일 때는 Segmentation을 수행하고 전송 중에서도 Packet Size가 크면 지나치는 라우터에서 Fragmentation이 일어날 수 있으며, UDP 프로토콜을 이용한 통신일 때 Fragmentation을 수행하고 전송 중에서도 Packet Size가 크면 지나치는 라우터에서 Fragmentation이 일어날 수 있습니다.

다르게 말하면 TCP 프로토콜에서는 4계층에서 Fragmentation 대신 Segmentation만 일어나지만, UDP 프로토콜에서는 Segmentation 대신 3계층에서 Fragmentation가 일어납니다.

## TCP/IP 모델

OSI 모델은 참조 모델일 뿐 실제 사용되는 인터넷 프로토콜은 7계층 구조를 완전히 따르지는 않는다. 인터넷 프로토콜 스택은 현재 대부분 TCP/IP를 따른다.

* 인터넷 프로토콜 중 가장 중요한 역할을 하는 TCP와 IP의 합성어로, 데이터의 흐름 관리, 정확성 확인, 패킷의 목적지 보장을 담당한다.

  * 데이터의 정확성 확인은 TCP
  * 패킷을 목적지까지 전송하는 일은 IP가 담당한다.

* TCP/IP의 4계층

  <img src="https://user-images.githubusercontent.com/33208360/117919310-ba8f9300-b327-11eb-9cf3-7baec27477c3.png" alt="image" style="zoom: 50%;" />
  
  * TCP/IP는 OSI 참조 모델과 달리 Applcation 계층 하나에서 Application, Presentation, Session 계층의 구현을 다 하고 있다.
  
  * 데이터는 단계별로 헤더(Data -> Segment -> Datagram -> Frame)를 붙여 전송하며 이를 **데이터 캡슐화** 라고 한다.

</br>

## TCP와 UDP

> https://velog.io/@hidaehyunlee/TCP-%EC%99%80-UDP-%EC%9D%98-%EC%B0%A8%EC%9D%B4

TCP와 UDP는 TCP/IP의 **전송 계층**에서 사용되는 프로토콜이다. 전송계층은 IP에 의해 전달되는 패킷의 오류를 검사하고 재전송 요구 등의 제어를 담당하는 계층이다.

TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol) 두 프로토콜은 모두 패킷을 한 컴퓨터에서 다른 컴퓨터로 전달해주는 IP 프로토콜을 기반으로 구현되어 있지만, 서로 다른 특징을 가지고 있다.

* 신뢰성이 요구되는 애플리케이션에서는 TCP를 사용하고, 간단한 데이터를 빠른 속도로 전송하고자 하는 애플리케이션에서는 UDP를 사용한다.

### TCP

네트워크 계층 중 전송 계층에서 사용하는 프로토콜로서, 장치들 사이에 논리적인 접속을 성립하기 위해 연결을 설정하여 **신뢰성을 보장하는 연결형 서비스**이다. TCP는 네트워크에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 옥텟(데이터, 메세지, 세그먼트라는 블록 단위)을 **안정적으로**, **순서대로**, **에러없이** 교환할 수 있게 한다.

**1) 특징**

* 연결형 서비스

  - 가상회선 방식을 제공한다.

  - 3-way handshaking 과정을 통해 연결을 설정하고, 4-way handshaking을 통해 연결을 해제한다.

* 흐름 제어 (Flow control)

  - 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지한다.

  * 송신하는 곳에서 감당이 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 일어나는 것을 막는다.
  * 수신자가 윈도우 크기(Window Size)값을 통해 수신량을 정할 수 있다.

* 혼잡 제어 (Congestion control)

  * 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지한다.
  * 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 막는다.

* 신뢰성이 높은 전송 (Reliable transmission)

  * Dupack-based retransmission

     : 정상적인 상황에서는 ACK 값이 연속적으로 전송되어야 한다. 그러나 ACK 값이 중복으로 올 경우 패킷 이상을 감지하고 재전송을 요청한다.

  * Timeout-based retransmission

    : 일정시간 동안 ACK 값 수신을 못할 경우 재전송을 요청한다.

* 전이중, 점대점 방식

  * 전이중 (Full-Duplex) : 전송이 양방향으로 동시에 일어날 수 있다.
  * 점대점 (Point to Point) : 각 연결이 정확히 2개의 종단점을 가지고 있다.

  => 멀티 캐스팅이나 브로드캐스팅을 지원하지 않는다.

**2) TCP Header 정보**

응용 계층으로부터 데이터를 받은 TCP는 헤더를 추가한 후에 이를 IP로 보낸다.

* 송수신자의 포트번호: TCP로 연결되는 가상 회선 양단의 송수신 프로세스에 할당되는 포트 주소
* 시퀀스 번호(Sequence Number): 송신자가 지정하는 순서 번호, 전송되는 바이트 수를 기준으로 증가.
* 응답 번호(ACK Number): 수신 프로세스가 제대로 수신한 바이트의 수를 응답하기 위해 사용.
* 데이터 오프셋(Data Offset): TCP 세그먼트의 시작 위치를 기준으로 데이터의 시작 위치를 표현(TCP헤더의 크기)

* 예약 필드(Reserved): 사용을 하지 않지만 나중을 위한 예약 필드이며 0으로 채워져야 한다.
* 제어 비트(Flag Bit): SYN, ACK, FIN등의 제어 번호
* 윈도우 크기(Window): 수신 윈도우의 버퍼 크기를 지정할 때 사용. 0이면 송신 프로세스의 전송 중지.
* 체크섬(Checksum): TCP 세그먼트에 포함되는 프로토콜 헤더와 데이터에 대한 오류 검출 용도
* 긴급 위치(Urgent Pointer): 긴급 데이터를 처리하기 위함. URG 플래그 비트가 지정된 경우에만 유효

:heavy_plus_sign: 제어 비트(Flag Bit) 정보

	* URG: 긴급 위치 필드가 유효한지 설정
 * ACK: 응답 번호 필드가 유효한지 설정. 클라이언트가 보낸 최초의 SYN 패킷 이후에 전송되는 모든 패킷은 이 플래그가 설정되어야 한다. 
   	* ACK은 송신측에 대하여 **수신측에서 긍정 응답**으로 보내지는 전송 제어용 캐릭터
   	* ACK번호를 사용하여 패킷이 도착했는지 확인한다. 송신한 패킷이 제대로 도착하지 않았으면 재송신을 요구한다.
* PSH: 수신 애플리케이션에 버퍼링된 데이터를 상위 계층에 즉시 전달할 때
* RST: 연결의 리셋이나 유효하지 않은 세그먼트에 대한 응답용
* SYN: 연결 설정 요구. 동기화 시퀀스 번호. 양쪽이 보낸 최초의 패킷에만 이 플래그가 설정되어 있어야 한다.
* FIN: 더이상 전송할 데이터가 없을 때 연결 종료 의사 표시

**3) TCP Connection(3-way handshake)**

TCP통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정

* 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다.
* 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.

1. 먼저 `open()`을 실행한 클라이언트가 `SYN`을 보내고 `SYN_SENT`상태로 대기한다.
2. 서버는 `SYN_RCVD`상태로 바꾸고 `SYN`과 응답 `ACK`를 보낸다.
3. `SYN`과 응답 `ACK`을 받은 클라이언트는 `ESTABLISHED`상태로 변경하고 서버에게 응답 `ACK`를 보낸다
4. 응답 `ACK`를 받은 서버는 `ESTABLISHED`상태로 변경한다.

**4) TCP Disconnection (4-way handshake)**

TCP의 연결을 해제하는 과정

1. 먼저 `close()`를 실행한 클라이언트가 `FIN`을 보내고 `FIN_WAIT1`상태로 대기한다.
2. 서버는 `CLOSE_WAIT`으로 바꾸고 응답 `ACK`을 전달한다. 동시에 해당 포트에 연결되어 있는 애플리케이션에 `close()`를 요청한다.
3. `ACK`을 받은 클라이언트는 상태를 `FIN_WAIT2`로 변경한다.
4. `close()`요청을 받은 서버 애플리케이션은 종료 프로세스를 진행하고 `FIN`을 클라이언트에 보내 `LAST_ACK`상태로 바꾼다.
5. `FIN`을 받은 클라이언트는 `ACK`을 서버에 다시 전송하고 `TIME_WAIT`으로 상태를 바꾼다. `TIME_WAIT`에서 일정 시간이 지나면 `CLOSED`된다. `ACK`을 받은 서버도 포트를 `CLOSED`로 닫는다.

:heavy_plus_sign: 누가 먼저 `close()`를 요청하느냐에 따라 상태가 달라질 수 있다. 서버가 먼저 종료하겠다고 `FIN`을 보낼 수 있고, 이런 경우 서버가 `FIN_WAIT1`상태가 된다.

<img src="https://user-images.githubusercontent.com/33208360/117923457-0134bb80-b32f-11eb-9bce-c3214ca9f7ad.png" alt="image" style="zoom:50%;" />

### UDP

**UDP Header 정보**

응용계층으로부터 데이터를 받은 UDP도 UDP 헤더를 추가한 후에 이를 IP로 보낸다.

* 송신자의 포트 번호: 데이터를 보내는 애플리케이션의 포트 번호
* 수신자의 포트 번호: 데이터를 받는 애플리케이션의 포트 번호
* 데이터의 길이: UDP헤더와 데이터의 총 길이
* 체크섬(Checksum): 데이터 오류 검사에 사용

TCP헤더와 다르게 UDP헤더에는 포함된 정보가 부실한 느낌마저 든다. UDP는 수신자가 데이터를 받는지 마는지 관심이 없기 때문이다. 즉, 신뢰성을 보장해주지는 않지만 간단하고 속도가 빠른 것이 특징이다.

### TCP, UDP 공통점

* 포트 번호를 이용하여 주소를 지정한다.
* 데이터 오류 검사를 위한 Checksum이 존재한다.

### TCP, UDP 차이점

* TCP는 연결형 프로토콜로 연결이 성공해야 통신이 가능하다. UDP는 비연결형 프로토콜로 연결 없이 통신이 가능하다.
* TCP는 데이터의 경계를 구분하지 않는다(Byte-Stream Service). UDP는 데이터의 경계를 구분한다(Datagram Service).
* TCP는 신뢰성있는 데이터 전송(데이터의 재전송 존재)을, UDP는 비신뢰성있는 데이터 전송(데이터의 재전송 없음)을 한다.
* TCP는 일대일(Unicast)통신을, UDP는 일대일, 일대다(Broadcast), 다대다(Multicast) 통신을 한다.

### TCP 관련 질문

1. TCP의 연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 단계가 차이나는 이유?

   Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 `FIN`에 대한 `ACK`만 보내고, 데이터를 모두 전송한 후에 자신도 `FIN`메시지를 보내기 때문이다.

2. 만약 Server에서 `FIN`플래그를 전송하기 전에 전송한 패킷이 Rounting 지연이나 패킷 유실로 인한 재전송 등으로 인해 `FIN`패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?

   이러한 현상에 대비하여 Client는 Server로부터 `FIN`플래그를 수신하더라도 일정 시간동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다. (TIME_WAIT 과정)

3. 초기 Sequence Number인 `ISN`을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유?

   Connection을 맺을 때 사용하는 포트는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 `SYN`을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 Number가 전송된다면 이전의 Connection으로부터 오는 패킷으로 인식할 수 있다. 이런 문제가 발생할 가능성을 줄이기 위해 난수로 `ISN`을 설정한다.

4. TCP UDP 사용 예시를 설명해 주세요

   TCP는 순서를 보장한다는 점과 신뢰도가 있다는 점에서 대부분의 HTTP 통신, 이메일이나 파일전송처럼 순서대로 도착해야 하는 상황에서 사용된다.

   UDP는 순서는 보장해주지 못하지만 실시간으로 반응해야하는 실시간 동영상 플레이어나 게임, 혹은 DNS에서 사용. DNS의 경우 누군가 도메인을 쳤을때마다 그때 그때 서버와 클라이언트가 커넥션을 맺으면 속도가 느려지기 때문에 UDP를 사용한다.

</br>

## HTTP와 HTTPS

> https://mangkyu.tistory.com/98

### HTTP란?

HTTP(Hyper Text Tranfer Protocol)란, **서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜**이다.

즉, HTTP는 인터넷에서 하이퍼텍스트를 교호나하기 위한 통신 규약으로, 80번 포트를 사용하고 있다. 따라서, HTTP 서버가 80번 포트에서 요청을 기다리고 있으며, 클라이언트는 80번 포트로 요청을 보내게 된다.

**구조**

애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동한다. HTTP는 상태를 가지고 있지 않는 Stateless 프로토콜이며 Method, Path, Version, Headers, Body 등으로 구성된다.

<img src="https://user-images.githubusercontent.com/33208360/117928142-1a8d3600-b336-11eb-8f83-3b0116f21713.png" alt="image" style="zoom: 50%;" />

하지만, HTTP는 암호화가 되지 않은 평문 데이터를 전송하는 프로토콜이었기 때문에, HTTP로 비밀번호나 주민등록번호 등을 주고 받으면 제 3자가 정보를 조회할 수 있었다. 이러한 문제를 해결하기 위해 HTTPS가 등장하게 되었다.

**:heavy_plus_sign: HTTP의 문제점**

* HTTP는 평문 통신이기 때문에 도청이 가능하다.
* 통신 상대를 확인하지 않기 때문에 위장이 가능하다.
* 완전성을 증명할 수 없기 때문에 변조가 가능하다.

### HTTPS란?

HyperText Transfer Protocol over Secure Socket Layer, HTTP over TLS, HTTP over SSL, HTTP Secure 등으로 불리는 HTTPS는 **HTTP에 데이터 암호화가 추가된 프로토콜**이다. HTTPS는 HTTP와 다르게 433번 포트를 사용하며, 네트워크 상에서 중간에 제 3자가 정보를 볼 수 없도록 공개키 암호화를 지원하고 있다.(+ 추가: 대칭키 암호화 방식과, 공개키 암호화 방식 두 가지를 사용한다.)

![image](https://user-images.githubusercontent.com/33089715/118095765-6eb61a00-b40b-11eb-809b-6a7fd664812e.png)

+ 새로운 애플리케이션 계층의 프로토콜이 아니라 HTTP 통신하는 소켓 부분을 SSL or TLS 라는 프로토콜로 대체하는 것이다. HTTP는 원래 TCP와 직접 통신 했지만, HTTPS에서는 HTTP는 SSL과 통신하고 SSL이 TCP와 통신한다.

**공개키/개인키**

HTTPS는 공개키/개인키 암호화 방식을 이용해 데이터를 암호화하고 있다. 공개키와 개인키는 서로를 위한 한쌍의 키이다.

(공개키: 모두에게 공개 가능한 키/ 개인키: 나만 가지고 알고 있어야하는 키)

* 공개키 암호화: 공개키로 암호화하면 개인키로만 복호화할 수 있다.

  -> 개인키는 나만 가지고 있으므로, 나만 볼 수 있다.

* 개인키 암호화: 개인키로 암호화하면 공개키로만 복호화할 수 있다. 

  -> 공개키는 모두에게 공개되어 있으므로, 내가 인증한 정보임을 알려 신뢰성을 보장할 수 있다.

**대칭키 암호화 방식**

인코딩과 디코딩에 같은 키를 사용하는 알고리즘이다.

+ 단점으로는 발송자와 수신자가 대화하기 위해 공유키를 사용해야 하기 때문에 대칭키를 전달하는 과정에서 키가 유출이 되면 암호의 내용을 복호화할 수 있기 때문에 위험하다.
+ 이를 보완하기 위해 나온 방법이 **공개키 암호화 방식**이다.

공개키 암호 방식은 알고리즘 계산방식이 느린 경향이 있다.
따라서 SSL은 암호화된 데이터를 전송하기 위해서 **공개키와 대칭키 암호화 방식을 혼합하여 사용**한다.
안전한 의사소통 채널을 수립할 때는 공개키 암호를 사용하고, 이렇게 만들어진 안전한 채널을 통해서 임시의 무작위 대칭키를 생성 및 교환한다. 해당 대칭키는 나머지 데이터 암호화에 활용한다.

+ 실제 데이터 암호화 방식 : 대칭키

+ 상기 대칭키를 서로 공유하기 위한 암호화 방식 : 공개키

**HTTPS의 동작 과정**

HTTPS는 SSL과 같은 프로토콜을 사용하여 공개키/개인키 기반으로 데이터를 암호화하고 있다. 데이터는 암호화되어 전송되기 때문에 임의의 사용자가 데이터를 조회하여도 원본의 데이터를 보는 것은 불가능하다.

서버는 클라이언트가 요청을 보낼대 암호화를 하기 위한 공개키를 생성해야 하는데, 일반적으로는 인증된 기관(Certificate Authority)에 공개키를 전송하여 인증서를 발급받고 있다.

(+ 추가)
**SSL 통신과정(핸드쉐이크 과정)**
+ 핸드쉐이크 -> 세션 -> 세션 종료 의 과정을 거친다.
+ 암호화된 HTTP 메시지를 교환하기 전에 클라이언트와 서버는 SSL 핸드쉐이크를 한다.
+ 핸드 쉐이크의 목적
   + 프로토콜 버전 번호 교환
   + 양쪽이 알고 있는 pre master secret 키 생성 및 교환
   + 양쪽의 신원 인증
   + 채널을 암호화 하기 위한 임시 세션 키 생성

   ![image](https://user-images.githubusercontent.com/33089715/118095701-59d98680-b40b-11eb-9306-8529b0e479e1.png)

1. client hello

    **클라이언트 측에서 생성한 랜덤 데이터**

    **클라이언트가 지원하는 암호화 방식들** : 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 해야한다. 이 협상을 위해서 클라이언트 측에서는 자신이 사용할 수 있는 암호화 방식을 전송한다.

    **세션아이디** : 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용하게 되는데 이 때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.

2. server hello / client hello 에 대한 응답

    **서버 측에서 생성한 랜덤 데이터**

    **서버가 선택한 암호화 방식들** : 서버 측에서는 클라이언트가 전달한 암호화 방식 중에서 자신이 사용할 수 있는 암호화 방식을 전송한다. 협상 종료

    **인증서**

3. 클라이언트는 서버의 인증서가 CA 에 의해서 발급된 것인지 확인하기 위해 클라이언트에 내장된 CA 리스트 확인
    - CA 리스트에 인증서가 없는 경우 : 사용자에게 경고 메시지
    - 인증서가 CA 에 의해서 발급 된 것인지 확인하기 위해 클라이언트에 내장된 CA 의 공개키를 이용해서 인증서를 복호화. 복호화에 성공했다면 인증서는 CA 의 개인키로 암호화된 문서임이 암시적으로 보증된 것이다.
4. 서버의 랜덤데이터 + 클라이언트의 랜덤데이터 → pre master secret 키를 생성
    - 이 후에 세션 단계에서 데이터를 주고 받을 때 암호화 하기위해 사용
    - 이 때 사용할 암호화 기법은 대칭키이기 때문에 pre master secret 값은 제 3자에게 절대로 노출되어서는 안된다.
    - pre master secret 값을 서버에 전달할 때는 공개키 방식을 사용. 서버의 공개키로 pre master secret 값을 암호화해서 서버로 전송하면 서버는 자신의 비공개 키로 안전하게 복호화 할 수 있다.
        - 그럼 서버의 공개키는 어떻게 구하나? 서버로부터 받은 인증서 안에 들어있다. 이 서버의 공개키를 이용해서 pre master secret 값을 암호화한 후에 서버로 전송하면 안전하게 전송할 수 있다.
5. pre master secret 키 복호화
6. master secret 키 및 session key 생성
    - 서버와 클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 master secret 값으로 만든다.
    - master secret 는 session key 를 생성
7. session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화 한 후 주고 받는다.
8. 클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.

### HTTP와 HTTPS

HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있다.

하지만 HTTPS를 이용하면 암호화/복호화의 과정이 필요하기 때문에 HTTP보다 속도가 느리다. (오늘날에는 거의 차이를 못느낄 정도) 또한, HTTPS는 인증서를 발급하고 유지하기 위한 추가 비용이 발생한다.

* 개인정보와 같은 민감한 데이터를 주고 받아야한다면 HTTPS를 이용해야 하지만, 단순한 정보 조회 등만을 처리하고 있다면 HTTP를 이용하면 된다.

## HTTP/1.1과 HTTP/2.0
### HTTP/1.1 동작방식

> https://www.popit.kr/%EB%82%98%EB%A7%8C-%EB%AA%A8%EB%A5%B4%EA%B3%A0-%EC%9E%88%EB%8D%98-http2/

HTTP는 웹 상에서 Client(IE, Chrome, Firefox)와 Server(httpd, nginx, etc...)간 통신을 위한 Protocol이다.

HTTP 1.1 프로토콜은 클라이언트와 서버간 통신을 위해 다음과 같은 과정을 거치게 된다.

<img src="https://user-images.githubusercontent.com/33089715/121461032-0302a500-c9e9-11eb-8649-ef977075487d.png" width = "300">

+ 기본적으로 Connection당 하나의 요청을 처리 하도록 설계되어있다.
+ 따라서 동시 전송이 불가능하고 요청과 응답이 순차적으로 이루어지게 된다.
+ HTTP1.1의 단점은 다음과 같다.

#### HOL(Head Of Line) Blocking - 특정 응답의 지연
+ HTTP/1.1의 connection당 하나의 요청처리를 개선할 수 있는 기법 중 pipelining이 존재하는데 이것은 하나의 Connection을 통해 다수 개의 파일을 요청/응답 받을수 있는 기법이다.
+ 이 pipelining의 문제점, 하나의 TCP 연결에서 3개의 이미지를 얻으려고 하는경우 HTTP의 요청 순서는 다음과 같다.
```
| --- a.png --- |

            | --- b.png --- |


                        | --- c.png --- |
```
+ 첫 번째 이미지를 요청하고 응답받고 다음 이미지를 요청하게 되는데, 만약 첫 번째 이미지를 요청하고 응답이 지연되면 두, 세번째 이미지는 당연히 대기하게 되며 이와같은 현상을 **HTTP의 Head of Line Blocking**이라 부른다.

#### RTT(Round Trip Time) 증가
+ http/1.1의 경우 일반적으로 하나의 connection에 하나의 요청을 처리한다.
+ 매 요청별로 connection을 만들게 되고 TCP 상에서 동작하는 HTTP의 특성상 3-way handshake가 반복적으로 일어나고 또한 불필요한 RTT 증가와 네트워크 지연을 초래하여 성능을 저하시킨다.

#### 무거운 Header 구조(특히 Cookie)
+ http/1.1의 헤더에는 많은 메타정보들이 저장되어 있다.
+ 사용자가 방문한 웹페이지는 다수의 http 요청이 발생하게 되는데 이 경우에 매 요청시 마다 중복된 헤더값을 전송하게 되며 해당 domain에 설정된 cookie 정보도 매 요청시 마다 헤더에 포함되어 전송된다.

### HTTP/2.0

> https://velog.io/@taesunny/HTTP2HTTP-2.0-%EC%A0%95%EB%A6%AC

SPDY(스피디/speedy로 발음)라는 구글의 비표준 개방형 네트워크 프로토콜에 기반한다. 기존의 HTTP methods, status codes, semantics 개념들이 동일하게 호환된다.
+ 퍼포먼스 향상이라는 목적을 가지며, 다음과 같은 특징들이 있다.

#### HTTP Header Data Compression(HTTP 헤더 데이터 압축)
+ 이전 Header의 내용과 중복되는 필드를 재전송 하지 않도록 하여 데이터를 절약한다.
+ 또한 기존에 HTTP Header가 Plain Text(평문)이었지만, HTTP/2에서는 Huffman Coding을 사용하는 HPACK이라는 Header 압축방식을 이용하여 데이터 전송 효율을 높였다.
<img src="https://user-images.githubusercontent.com/33089715/121462120-0dbe3980-c9eb-11eb-948a-4b5cf86293ef.png" width = "300">

> Huffman Coding 방식 : 데이터 문자의 빈도에 따라서 다른 길이의 부호를 사용하는 알고리즘


#### Server Push
+ 클라이언트가 요청하지 않은 JavaScript, CSS, Font, 이미지 파일 등과 같이 필요하게 될 특정 파일들을 서버에서 단일 HTTP 요청 응답 시 함께 전송할 수 있다.


#### HTTP1.x의 HOF Blocking 문제 해결
+ HTTP/1.1 까지는 한 번에 하나의 파일만 전송이 가능했다. 이로 인해 선행하는 파일의 전송이 늦어지면, 전체 파일 전송 시간이 늘어나는 문제가 발생했다.
+ HTTP/2에서는 여러 파일을 한번에 병렬 전송하여, 이러한 문제를 해결했다.
+ TCP 연결 하나로 여러 요청과 응답들을 병렬적으로 보낼 수 있다. 덕분에 웹사이트 로딩이 빨라진다.
+ 아래 이미지 처럼, 하나의 커넥션에서 여러 병렬 스트림(3개)이 존재 할 수 있다. stream이 뒤섞여서 전송될 경우, stream number를 이용해 수신측에서 재조합된다.

   <img src="https://user-images.githubusercontent.com/33089715/121462373-77d6de80-c9eb-11eb-8342-ac5f6f0fa1ba.png" width = "500">

#### Stream 우선순위
+ HTTP 메시지가 많은 개별 프레임으로 분할될 수 있고 여러 프레임을 다중화(Multiplexing)할 수 있게 되면서, 스트림의 우선순위를 지정할 필요가 생겼다.
+ 클라이언트는 우선순위 지정을 위해 '우선순위 지정 트리'를 사용하여 서버의 스트림처럼 우선 순위를 지정할 수 있다.
+ 서버는 우선순위가 높은 응답이 클라이언트에 우선적으로 전달될 수 있도록 대역폭을 설정한다.

</br>

## GET과 POST

> https://mangkyu.tistory.com/17

사용자가 어떤 홈페이지로 이동하기 위해서 URL을 브라우저 주소창에 작성하고 엔터를 누르면 원하는 페이지로 이동하게 된다. 사용자는 단순히 URL을 입력했을 뿐이지만 서버 내부에서는 클라이언트의 요청에 응답(웹페이지로 표현)하기 위해서 처리를 해주어야 한다. 여기서 **클라이언트가 서버로 요청을 보내는 방법**인 HTTP Method에는 크게 2가지 방식이 있는데, 바로 **GET방식과 POST방식**이다.

### GET 방식

어떠한 정보를 가져와서 조회하기 위해서 사용되는 방식이다.

**[특징]**

* URL에 변수(데이터)를 포함시켜 요청한다.
* 데이터를 Header에 포함하여 전송한다.
* URL에 데이터가 노출되어 보안에 취약하다.
* 캐싱할 수 있다.

GET방식은 간단한 데이터를 URL에 넣도록 설계된 방식으로 데이터를 보내는 양에 한계가 있다. HTTP 자체는 GET 방식의 URL 길이에 제약을 두고 있지는 않지만, 브라우저에서 최대 길이를 제한하고 있으며 URL 형식에 맞지 않는 파라미터 이름이나 값은 인코딩되어 전달해야 한다. 

(특별히 전송하는 데이터가 없으므로 GET방식에서 바디는 보통 빈 상태로 전송이 되며, 헤더의 내용 중 Body의 데이터를 설명하는 Content-type 헤더 필드도 들어가지 않는다.)

**예)** `www.mangkyu.com/login?id=mang&pw=kyu`

* `?`를 통해 URL의 끝을 알린다.
* `id`라는 key에 대해서는 `mang`이라는 value를, `pw`라는 key에 대해서는 `kyu`라는 value를 전송하는 예시. 여러개의 key와 value를 보내는 경우 `&`를 사용하여 이어준다.
* 최소한의 보안 유지도 하지 않기 때문에 실제 웹사이트에서 중요한 정보를 GET방식으로 사용하면 개인정보가 노출되는 문제가 발생한다. 
* GET방식을 사용해서 데이터를 노출시키는 경우는 개인정보가 포함되지 않는 상황에서 캐싱을 하여 속도를 높이거나 즐겨찾기를 편리하게 하기 위해 사용되는 경우가 많다.

### **POST 방식**

데이터를 서버로 제출하여 추가 또는 수정하기 위해서 사용하는 방식이다.

**[특징]**

* URL에 변수(데이터)를 노출하지 않고 요청한다.
* 데이터를 Body에 포함시킨다.
* URL에 데이터가 노출되지 않아서 기본 보안은 되어있다.
* 캐싱할 수 없다.

GET방식은 URL에 데이터를 붙여서 전송하는 반면에 POST방식은 Body에 데이터를 넣어서 전송한다. 따라서, 헤더 필드 중 Body의 데이터를 설명하는 Content-Type이라는 헤더 필드가 들어가고 어떠한 데이터 타입인지를 명시해주어야 한다.

데이터를 Body에 포함시키는 이점 때문에 메세지 길이의 제한은 없지만 최대 요청을 받는 시간인 Time Out이 존재하므로 클라이언트에서 페이지를 요청하고 기다리는 시간이 존재한다.

실제로 POST방식은 URL에 데이터가 노출되지 않으므로 즐겨찾기나 캐싱이 불가능하지만 쿼리스트링 데이터 뿐만 아니라, 라디오 버튼, 텍스트 박스와 같은 객체들의 값도 전송 가능하다.

### GET vs POST 비교

|        처리방식        | GET 방식     | POST 방식  |
| :--------------------: | ------------ | :--------: |
| URL에 데이터 노출 여부 | O            |     X      |
|     데이터의 위치      | Header(헤더) | Body(바디) |
|     캐싱 가능 여부     | O            |     X      |

### GET, POST 관련 질문
조회에 POST 가 아닌 GET 을 사용하는 이유?
1. 설계 원칙에 따라 GET 방식은 서버에 여러 번 요청을 하더라도 동일한 응답이 돌아와야함
    - GET 방식은 가져오는 것으로, 서버의 데이터나 상태를 변경시키지 않아야함
    - POST 방식은 서버의 값이나 상태를 바꾸기 위한 용도
2. 웹에서 모든 리소스는 Link 할 수 있는 URL 을 가지고 있어야 함
    - URL 을 Copy and Past했을 때, 해당 페이지로 접속 가능해야함
    - POST 방식을 사용할 경우 링크의 정보가 Body 안에 들어있기 때문에 해당 페이지로 접속이 불가능

GET방식이 POST방식보다 속도가 빠르다?
+ 빠르다. 이유는 GET방식의 요청은 캐싱(한번 접근 후, 또 요청할 시 빠르게 접근하기 위해 데이터를 저장시켜 놓는다)때문에 빠른것이다.

</br>

## 쿠키와 세션

> https://devuna.tistory.com/23

HTTP는 인터넷상에서 데이터를 주고 받기 위해 서버/클라이언트 모델을 따르는 통신 규약이다. 이 HTTP 프로토콜에는 **비연결성과 비상태성**이라는 특징이 있다. 이는 서버의 자원을 절약하기 위해 모든 사용자의 요청 마다 연결과 해제의 과정을 거치기 떄문에 연결상태가 유지되지 않고, 연결 해제 후에 상태정보가 저장되지 않는다는 것이다.

=> 이로 인해 사용자를 식별할 수 없어서 같은 사용자가 요청을 여러번 하더라도 매번 새로운 사용자로 인식하는 단점이 있다.

=> **이렇게 HTTP의 비연결성과 비상태성을 보완하여 서버가 클라이언트를 식별하게 해주는 것이 쿠키와 세션이다.** (사용하고 있는 웹사이트를 생각해보면 로그인을 한 번 하고 나면 그 사이트에서는 다시 로그인할 필요 없이 여러 페이지의 기능들을 이용할 수 있고, 심지어 브라우저를 종료했다가 나중에 다시 접속했을 때도 그 로그인 상태를 유지할 수 있다.)

### 쿠키

웹사이트에 접속할 때 생성되는 정보를 담은 임시 파일, 즉 서버가 사용자의 웹 브라우저에 저장하는 데이터를 말한다. 쿠키의 데이터 형태는 Key와 Value로 구성되고 String형태로 이루어져 있다.

쿠키는 서버를 대신해서 이러한 정보들을 웹 브라우저에 저장(정확히는 웹 브라우저를 이용하고 있는 컴퓨터에 저장)하고 사용자가 요청할 때 그 정보를 함께 보내서 서버가 사용자를 식별할 수 있게 해준다.

**사용 목적**

1. 세션 관리(Session Menagement)

   로그인, 사용자 닉네임, 접속 시간, 장바구니 등의 서버가 알아야 할 정보들을 저장한다.

2. 개인화(Personalization)

   사용자마다 다르게 그 사람에 적절한 페이지를 보여줄 수 있다.

3. 트래킹(Tracking)

   사용자의 행동과 패턴을 분석하고 기록한다.

**사용 예시**

쿠키가 있기 때문에 여러 페이지를 이동할 때마다 로그인을 하지 않고 사용자 정보를 유지할 수 있는 것이다. 쿠키가 없다면 'ID 저장', '로그인 상태 유지', '일주일간 다시 보지 않기', '최근 검색한 상품들을 광고에서 추천', '쇼핑몰 장바구니 기능' 등의 정보를 파라미터로 넘겨줘야 한다.

<img src="https://user-images.githubusercontent.com/33208360/117935551-cc306500-b33e-11eb-88d5-e5bd1e407dec.png" alt="image" style="zoom:50%;" />

1. 서버에서는 사용자로부터 요청이 있을 때 사용자를 구분하기 위한 임시 쿠키 하나를 보내 저장하도록 한다.

2. 저장된 쿠키는 웹 브라우저의 쿠키 저장소에 저장된다.

3. 이후 같은 사이트의 서버를 방문할 때마다, 저장된 쿠키를 요청할 header에 담아 함께 다시 서버로 전송한다.

   서버는 전송받은 쿠키와 서버에 저장된 사용자 정보를 비교하여 같은 사용자임을 확인한다.

**단점**

1. 방문했던 웹사이트에 대한 정보 및 개인정보가 기록되기 때문에 사생활을 침해할 소지가 있으며, 이를 해소하기 위해서 웹브라우저 자체에 쿠키 거부 기능이 있다. 이러한 쿠키에 대한 거부가 웹 브라우저에 설정되어 있으면 쿠키 본래의 목적인 웹브라우저와의 연결을 지속시키는 기능을 수행할 수 없는 경우가 발생한다.
2. 서버가 가지고 있는 것이 아니라 사용자에게 저장되기 때문에, 임의로 고치거나 지울 수 있고, 가로채기 쉬워 보안이 취약하다. 따라서, 쿠키에 민감하거나 중요한 정보를 담는 것은 위험하다.

=> 이러한 단점을 보완해주는 것이 세션이다.

### 세션

세션 아이디는 웹브라우저 당 1개씩 생성되어 웹 컨테이너에 저장되며 브라우저 종료 시 소멸된다. 로그인한 사용자에 대해서만 세션을 생성하는 것이 아니라 로그아웃하면 새로운 사용자로 인식해서 새로운 세션이 생성된다. (쿠키는 웹브라우저에 저장된 것이기 때문에 로그아웃 유무와 관계없이 삭제하지 않으면 유지된다.)

아이디, 닉네임 등의 정보를 세션에 담아두면 요청이 있을 때 마다, DB에 접근할 필요가 없어 효율적이다. 

### 쿠키와 세션의 차이점

1. 저장위치
   * 쿠키: 클라이언트의 웹 브라우저가 지정하는 메모리 또는 하드디스크에 저장(로컬)
   * 세션: 서버의 메모리에 저장(서버)
2. 저장 형식
   * 쿠키: text형식으로 저장
   * 세션: Object형식으로 저장
3. 리소스(사용되는 자원)
   * 쿠키: 클라이언트에 저장되고 클라이언트의 메모리를 사용하기 때문에 서버의 자원을 사용하지 않음
   * 세션: 세션은 서버에 저장되고 서버의 메모리로 로딩이 되기 때문에 세션이 생길 때마다 서버의 리소스를 차지
4. 용량 제한
   * 쿠키: 클라이언트도 모르게 접속되는 사이트에 의하여 설정될 수 있기 때문에 쿠키로 인해 문제가 발생하는 것을 막고자 한 도메인당 20개, 하나의 쿠키당 4KB로 제한
   * 세션: 갯수나 용량에 제한이 없음
5. 만료 시점
   * 쿠키: 저장할 때 expires 속성을 정의해 무효화 시키면 삭제될 날짜를 지정할 수 있다. 따로 지정하지 않은 경우에는 브라우저 종료시 만료된다.
   * 세션: 클라이언트가 로그아웃하거나, 설정한 시간동안 반응이 없을 경우 무효화되기 때문에 정확한 시점을 알 수 없다.
6. 보안
   * 쿠키 : 탈취와 변조가 가능
   * 세션 : ID 값만 가지고 있고, 서버에도 저장되어 있기 때문에 상대적으로 안전하다.
7. 속도
   * 쿠키 : 파일에서 읽기 때문에 상대적으로 빠르다.
   * 세션 : 요청마다 서버에서 처리를 해야하기 때문에 비교적 느리다.

**:heavy_plus_sign:정리**

* 쿠키는 사용자의 편의를 위한 것이며, 지워져도 되고 가로채이더라도 상관없는 수준의 정보들을 브라우저에 저장한다.
* 세션은 서버 안에서 다뤄지는 것이며, 사용자나 다른 누군가에게 노출되면 안되는 정보들은 세션으로 서비스 제공자가 직접 관리한다. 많으면 서버에 부담이 될 수 있다.

</br>

## DNS

> https://velog.io/@gparkkii/HTTPDNS

### DNS란?

DNS(Domain Name System)은 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행할 수 있도록 하기 위해 개발되었다.

인터넷 도메인 주소 체계로서 `www.example.com`과 같은 컴퓨터의 도메인 이름을 `192.168.1.0`과 같은 IP 주소로 변환하고 라우팅 정보를 제공하는 분산형 데이터베이스 시스템이며 인터넷의 전화번호부라고 불린다.

IP는 기억하기 어렵고 변경될 수 있다는 단점을 가지고 있는데 DNS가 이를 상쇄시켜준다.

### DNS 프로세스

특정 컴퓨터 또는 네트워크로 연결된 임의의 장치의 주소를 찾기 위해, 사람이 이해하기 쉬운 도메인 이름을 숫자로 된 식별 번호 IP 주소로 변환해준다.

도메인 명 등록 => IP주소로 변환

DNS 서버에 도메인을 등록한 후에, 도메인으로 접근하게 되면 DNS서버에서 도메인에 해당하는 IP를 지급하게 된다. (IP가 바뀔 경우 DNS에 변경)

DNS 네임 서버는 도메인을 위한 DNS 레코드를 저장하는 서버로 데이터베이스에 대한 쿼리의 응답정보와 함께 응답한다.

### 작동원리
![image](https://user-images.githubusercontent.com/33089715/118097776-12082e80-b40e-11eb-8101-433119bc57eb.png)

1. 웹 브라우저에 www.naver.com을 입력하면 Local DNS에게 "www.naver.com"이라는 hostname에 대한 IP 주소를 질의, Local DNS에 없으면 다른 DNS name 서버 정보를 받음(Root DNS 정보를 전달 받음)

   > Root DNS는 인터넷의 도메인 네임 시스템의 루트존, 루트 존의 레코드 요청에 직접 응답하고 적절한 최상위 도메인에 대해 권한이 있는 네임 서버 목록을 반환

2. Root DNS 서버에 "www.naver.com" 질의
3. Root DNS 서버로 부터 "com 도메인"을 관리하는 TLD(Top-Level Domain) 이름 서버 정보를 전달 받음
4. TLD에 "www.naver.com" 질의
5. TLD엣 "name.com" 관리하는 DNS 정보 전달
6. "naver.com" 도메인을 관리하는 DNS 서버에 "www.naver.com" 호스트 네임에 대한 IP 주소 질의
7. Local DNS 서버에게 www.naver.com의 IP 주소 응답
8. Local DNS 서버는 www.naver.com에 대한 IP 주소 캐싱하고 IP 주소 정보 전달

</br>

## REST, REST API, RESTful

> https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html

### REST (Representational State Transfer)

자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미한다.

즉, 자원(resource)의 표현(representation)에 의한 상태 전달

* 자원: 해당 소프트웨어가 관리하는 모든것 (예: 문서, 그림, 데이터, 소프트웨어 자체 등)
* 자원의 표현: 그 자원을 표현하기 위한 이름 (예: DB의 학생 정보가 자원일 때, 'student'를 자원의 표현으로 정한다.)
* 상태 전달: 데이터가 요청되어지는 시점에서 자원의 상태(정보)를 전달한다. JSON 혹은 XML을 통해 데이터를 주고 받는 것이 일반적이다.

월드 와이드 웹(www)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식

* REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다.
* REST는 네트워크 상에서 Client와 Server 사이의 통신 방식 중 하나이다.

**REST의 구체적인 개념**

* HTTP URI(Uniform Resource Identifier)를 통해 자원을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.

  즉, REST는 자원 기반의 구조(ROA, Resource Oriented Architecture) 설계의 중심에 Resource가 있고 HTTP Method를 통해 Resource를 처리하도록 설계된 아키텍처를 의미한다.

  * 웹 사이트의 이미지, 텍스트, DB 내용 등의 모든 자원에 고유한 ID인 HTTP URI를 부여한다.

  * CRUD Operation

    Create: 생성(POST)

    Read: 조회(GET)

    Update: 수정(PUT)

    Delete: 삭제(DELETE)

    HEAD: header 정보 조회(HEAD)

**REST의 장점**

* HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구출할 필요가 없다.
* HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해준다.
* HTTP 표준 프로코콜을 따르는 모든 플랫폼에서 사용이 가능하다.
* Hypermedia API의 기본을 충실히 지키면서 범용성을 보장한다.
* REST API메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다.
* 여러가지 서비스 디자인에서 생길 수 있는 문제를 최소화한다.
* 서버와 클라이언트의 역할을 명확하게 분리한다.

**REST의 단점**

* 표준이 존재하지 않는다.
* 사용할 수 있는 메소드가 4가지 밖에 없다. (HTTP Method형태가 제한적이다.)
* 브라우저를 통해 테스트할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL보다 Header값이 왠지 더 어렵게 느껴진다.
* 구형 브라우저가 아직 제대로 지원해주지 못하는 부분이 존재한다. (PUT, DELETE를 사용하지 못하는점. pushState를 지원하지 않는 점)

**REST가 필요한 이유**

* 애플리케이션 분리 및 통합
* 다양한 클라이언트의 등장
* 최근의 서버 프로그램은 다양한 브라우저와 안드로이드폰, 아이폰과 같은 모바일 디바이스에서도 통신할 수 있어야 한다.
* 이러한 멀티 플랫폼에 대한 지원을 위해 서비스 자원에 대한 아키텍처를 세우고 이용하는 방법을 모색한 결과, REST에 관심을 가지게 되었다.

**REST 구성요소**

* 자원(Resource): URI
  * 모든 자원에 고유한 ID가 존재하고, 이 자원은 Server에 존재한다.
  * 자원을 구별하는 ID는 '/group/:group_id'와 같은 HTTP **URI**이다.
  * Client는 URI를 이용해서 자원을 지정하고 해당 자원의 상태에 대한 조작을 Server에 요청한다.
* 행위(Verb): HTTP Method
  * HTTP프로토콜의 Method를 사용한다.
  * HTTP 프로토콜은 GET, POST, PUT, DELETE와 같은 메소드를 제공한다.
* 표현(Representation of Resource)
  * Client가 자원의 상태에 대한 조작을 요청하면 Server는 이에 적절한 응답(Representation)을 보낸다.
  * REST에서 하나의 자원은 JSON, XML, TEXT, RSS 등 여러 형태의 Representation으로 나타내어질 수 있다.
  * JSON 또는 XML을 통해 데이터를 주고받는 것이 일반적이다.

**특징**

* Server-Clinet (서버-클라이언트 구조)

  * 자원이 있는 쪽이 Server, 자원을 요청하는 쪽이 Client가 된다.
  * REST Server: API를 제공하고 비즈니스 로직 처리 및 저장을 책임진다.
  * Client: 사용자 인증이나 context(세션, 로그인 정보)등을 직접 관리하고 책임진다.
  * 서로 간 의존성이 줄어든다.

* Stateless(무상태)

  * HTTP 프로토콜을 Stateless Protocol이므로 REST 역시 무상태성을 갖는다.

  * Client는 context를 Server에 저장하지 않는다. 즉, 세션과 쿠키와 같은 context 정보를 신경쓰지 않아도 되므로 구현이 단순해진다.

  * Server는 각각의 요청을 완전히 별개의 것으로 인식하고 처리한다.

    각 API 서버는 Client의 요청만을 단순 처리한다. 즉, 이전 요청이 다음 요청의 처리에 연관되어서는 안된다. 물론 이전 요청이 DB를 수정하여 DB에 의해 바뀌는 것은 허용한다.

    Server의 처리 방식에 일관성을 부여하고 부담이 줄어들며, 서비스의 자유도가 높아진다.

* Cacheable(캐시 처리 가능)

  * 웹 표준 HTTP 프로토콜을 그대로 사용하므로 웹에서 사용하는 기존 인프라를 그대로 활용할 수 있다.

    즉, HTTP가 가진 가장 강력한 특징 중 하나인 캐싱 기능을 적용할 수 있다.

    HTTP프로토콜 표준에서 사용하는 Last-Modified 태그나 E-Tag를 이용하면 캐싱 구현이 가능하다.

  * 대량의 요청을 효율적으로 처리하기 위해 캐시가 요구된다.

  * 캐시 사용을 통해 응답시간이 빨라지고 RESR server 트랜잭션이 발생하지 않기 때문에 전체 응답시간, 성능, 서버의 자원 이용률을 향상시킬 수 있다.

* Layered System (계층화)

  * Client는 REST API Server만 호출한다.

  * REST Server는 다중 계층으로 구성될 수 있다.

    API Server는 순수 비즈니스 로직을 수행하고, 그 앞단에 보안/로드밸런싱/암호화/사용자 인증 등을 추가하여 구조상의 유연성을 줄 수 있다.

    또한, 로드밸런싱, 공유 캐시 등을 통해 확장성과 보안성을 향상시킬 수 있다.

  * Proxy, 게이트웨이 같은 네트워크 기반의 중간 매체를 사용할 수 있다.

* Code-On-Demand(optional)

  * Server로부터 스크립트를 받아서 Client에서 실행한다. 반드시 충족할 필요는 없다.

* Uniform Interface(인터페이스 일관성)

  * URI로 지정한 Resource에 대한 조작을 통일되고 한정적인 인터페이스로 수행한다.
  * HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다. 특정 언어나 기술에 종속되지 않는다.

### REST API

REST 기반으로 서비스 API를 구현한 것.

최근 OpenAPI(누구나 사용할 수 있도록 공개된 API), 마이크로 서비스(하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처) 등을 제공하는 업체 대부분은 REST API를 제공한다.

**:heavy_plus_sign: API란?**

데이터와 기능의 집합을 제공하여 컴퓨터 프로그램 간 상호작용을 촉진하며, 서로 정보를 교환가능하도록 하는것

**특징**

* 사내 시스템들도 REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다.
* REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다.
* 즉, REST API를 제작하면 델파이 클라이언트 뿐 아니라, 자바, C#, 웹 등을 이용해 클라이언트를 제작할 수 있다.

**REST API 설계 기본 규칙**

1. URI는 정보의 자원을 표현해야 한다.

   * resource는 동사보다는 명사를, 대문자보다는 소문자를 사용한다.
   * resource의 도큐먼트 이름으로는 단수 명사를 사용해야 한다.
   * resource의 컬렉션 이름으로는 복수 명사를 사용해야 한다.
   * resource의 스토어 이름으로는 복수 명사를 사용해야 한다.

   예) `GET /Member/1` => `GET /members/1`

2. 자원에 대한 행위는 HTTP Method(GET, PUT, POST, DELETE 등)로 표현한다.

   * URI에 HTTP Method가 들어가면 안된다.

     예) `GET /members/delete/1` => `DELETE /members/1`

   * URI에 행위에 대한 동사 표현이 들어가면 안된다. 즉, CRUD기능을 나타내는 것은 URI에 사용하지 않는다.

     예) `GET /member/show/1` => `GET /members/1`

     예) `GET /members/insert/2` => `POST /members/2`

   * 경로 부분 중 변하는 부분은 유일한 값으로 대체한다. 즉, :id는 하나의 특정 resource를 나타내는 고유값이다.

     예) student를 생성하는 route: `POST /students`

     예) id=12인 student를 삭제하는 route: `DELETE/students/12`

**REST API 설계 규칙**

1. 슬래시 구분자(`/`)는 계층 관계를 나타내는데 사용한다.

2. URI 마지막 문자로 슬래시(`/`)를 포함하지 않는다.

   URI에 포함되는 모든 글자는 리소스의 유일한 식별자로 사용되어야 하며 URI가 다르다는 것은 리소스가 다르다는 것이고, 역으로 리소스가 다르면 URI도 달라져야 한다.

   REST API는 분명한 URI를 만들어 통신을 해야하기 때문에 혼동을 주지 않도록 URI 경로의 마지막에는 슬래시(`/`)를 사용하지 않는다.

3. 하이픈(`-`)은 URI 가독성을 높이는데 사용

4. 밑줄(`_`)은 URI에 사용하지 않는다.

5. URI경로에는 소문자가 적합하다. 

   대문자는 피하도록 한다. RFC 3986(URI 문법 형식)은 URI 스키마와 호스트를 제외하고는 대소문자를 구별하도록 규정하기 때문이다.

6. 파일확장자는 URI에 포함하지 않는다.

   REST API에서는 메시지 바디 내용의 포멧을 나타내기 위한 파일 확장자를 URI안에 포함시키지 않는다.

7. 리소스간에는 연관관계가 있는 경우

   `/리소스명/리소스ID/관계가 있는 다른 리소스명`

### RESTful

일반적으로 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이다. REST API를 제공하는 웹 서비스를 RESTful하다고 할 수 있다.

RESTful은 REST를 REST답게 쓰기 위한 방법으로, 누군가가 공식적으로 발표한 것이 아니다. 즉, REST원리를 따르는 시스템은 RESTful이란 용어로 지칭된다.

**목적**

* 이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것
* RESTful한 API를 구현하는 근본적인 목적이 성능 향상에 있는 것이 아니라 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는 것이 주 동기이니, 성능이 중요한 상황에서는 굳이 RESTful한 API를 구현할 필요는 없다.

**RESTful하지 못한 경우**

* CRUD기능을 모두 POST로만 처리하는 API
* route에 resource, id 외의 정보가 들어가는 경우


URI와 URL의 차이?(참고)

<img src="https://user-images.githubusercontent.com/33089715/118091699-16c8e480-b406-11eb-9f23-cfccab242166.png"
     width="200">

![image](https://user-images.githubusercontent.com/33089715/118091811-3cee8480-b406-11eb-8832-8520653a2fc2.png)

+ URI (Uniform Resource Identifier) : 인터넷 자원을 나타내는 고유 식별자이다. 인터넷에 있는 id라고 생각하면 되기 때문에, URI는 유일하다. 

+ URL (Uniformed Resource Locator)
   + 프로토콜 포함
   + 해당 자원의 위치, Path를 의미
   + 일반적으로 사이트 도메인을 자주 의미함.
   + 웹 상 뿐만 아니라 컴퓨터 네트워크상의 자원은 모두 나타낼 수 있다.

+ URN (Uniformed Resource Name)
   + 프로토콜 포함 X
   + 해당 자원의 이름을 의미
   + 독립적인 자원 지시자
   + Page 이후 부분까지 포함

+ 정리 :
1. URI 는 네트워크 상 자원을 가리키는 일종의 고유 식별자(ID) 이다.

2. URL, URN 은 URI 에 포함되는 개념이며 URL 은 자원의 위치, URN 은 자원의 이름 을 의미한다. 

출처 : https://programming119.tistory.com/194
</br>

## SOCKET

> https://helloworld-88.tistory.com/215

### SOCKET이란?

프로세스가 데이터를 보내거나 받기 위해서는 반드시 소켓을 열어서 데이터를 써보내거나 소켓으로부터 데이터를 읽어들여야 한다.

소켓은 프로토콜, IP 주소, 포트 넘버로 정의된다.

소켓은 떨어져 있는 두 호스트를 연결해주는 도구로서, 인터페이스의 역할을 하는데 데이터를 주고 받을 수 있는 구조체로 소켓을 통해 데이터 통로가 만들어진다. 이러한 소켓은 역할에 따라 서버 소켓, 클라이언트 소켓으로 구분된다.

**소켓 통신의 흐름**

<img src="https://user-images.githubusercontent.com/33208360/117991625-31a14780-b379-11eb-8275-29bfb8e30aaa.png" alt="image" style="zoom:50%;" />

**서버 (Server)**

클라이언트 소켓의 연결 요청을 대기하고, 연결 요청이 오면 클라이언트 소켓을 생성하여 통신이 가능하게 한다.

1. `socket()`함수로 소켓을 생성
2. `bind()`함수로 ip와 port번호를 설정하게 된다.
3. `listen()`함수로 클라이언트의 접근 요청에 수신 대기열을 만들어 몇 개의 클라이언트를 대기 시킬지 결정
4. `accept()`함수를 사용하여 클라이언트와의 연결을 기다린다.

**클라이언트 (Client)**

실제로 데이터 송수신이 일어나는 곳이다.

1. `socket()`함수로 가장 먼저 소켓을 연다.
2. `connect()`함수를 이용하여 통신할 서버의 설정된 ip와 port번호에 통신을 시도
3. 통신 시도 시, 서버가 `accept()`함수를 이용하여 클라이언트의 socket descriptor를 반환
4. 이를 통해 클라이언트와 서버가 서로 `read()`, `write()`를 하며 통신 (이 과정이 반복된다)

### 종류

**스트림 (TCP)**

* 양방향으로 바이트 스트림을 전송, 연결 지향성
* 오류 수정, 전송 처리, 흐름제어 보장
* 송신된 순서에 따라 중복되지 않게 데이터를 수신 -> 오버헤드가 발생한다.
* 소량의 데이터보다 대량의 데이터 전송에 적합하다 -> TCP를 사용

**데이터그램 (UDP)**

* 비연결형 소켓
* 데이터의 크기에 제한이 있음
* 확실하게 전달이 보장되지 않음. 데이터가 손실돼도 오류가 발생하지 않음
* 실시간 멀티미디어 정보를 처리하기 위해 주로 사용. 예) 전화

### HTTP 통신과 SOCKET 통신의 비교

**HTTP 통신**

Clinet의 요청(Request)이 있을 때만 서버가 응답(Response)하여 해당 정보를 전송하고 곧바로 연결을 종료하는 방식

* 특징
  * Client가 요청을 보내는 경우에만 Server가 응답하는 단방향 통신이다.
  * Server로부터 응답을 받은 후에는 연결이 바로 종료된다.
  * 실시간 연결이 아니고, 필요한 경우에만 Server로 요청을 보내는 상황에 유용하다.
  * 요청을 보내 Server의 응답을 기다리는 애플리케이션의 개발에 주로 사용된다.

**SOCKET 통신**

Server와 Client가 특정 Port를 통해 실시간으로 양방향 통신하는 방식

* 특징
  * Server와 Client가 계속 연결을 유지하는 양방향 통신이다.
  * Server와 Client가 실시간으로 데이터를 주고받는 상황이 필요한 경우에 사용된다.
  * 실시간 동영상 Streaming이나 온라인 게임 등과 같은 경우에 자주 사용된다.


## 기타 질문
### Http Request Status Code에 대해 아는대로 설명해보세요

크게 앞자리 숫자를 기준으로 5가지 그룹으로 나누어 집니다.

+ 1XX : 정보(조건부) 응답
+ 2XX : 성공
+ 3XX : Ridirection Message Client는 요청을 마무리하기 위해 추가 동작을 해야합니다.
+ 4XX : Client 요청 오류, Client가 전송한 코드에 오류가 있음
+ 5XX : 서버 오류
