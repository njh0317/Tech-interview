# Data Structure

1. [Array vs LinkedList](#array-vs-linkedlist)
   * [Array (배열)](#array-배열)
   * [LinkedList](#linkedlist)
   * [Array와 LinkedList 차이점?](#array와-linkedlist-차이점)
   * [결론](#결론)
2. [ArrayList vs LinkedList](arraylist-vs-linkedlist)

   * [ArrayList](#arraylist)
   * [LinkedList](#linkedlist)
   * [데이터 검색, 삽입, 삭제 성능 비교](#데이터-검색-삽입-삭제-성능-비교)
3. [HashTable](#hashtable)

   * [HashTable(해시테이블)이란?](#hashtable해시테이블이란)
   * [Hash값이 충돌하는 경우](#hash값이-충돌하는-경우분리연결법-개방-주소법-resizing)
   * [해시테이블의 시간 복잡도](#해시테이블의-시간-복잡도)
   * [HashTable의 장점](#hashtable의-장점)
   * [HashTable의 단점](#hashtable의-단점)
   * [Java의 HashMap과 Hashtable의 차이](#java의-hashmap과-hashtable의-차이)
4. [Stack](#stack)
5. [Queue](#queue)
   * [스택으로 큐 구현](#스택으로-큐-구현)
   * [큐로 스택 구현](#큐로-스택-구현)
6. [Priority Queue](#priority-queue)
    * [힙으로 구현하는 이유?](#힙으로-구현하는-이유)
7. [Graph](#graph)
   * [관련 용어](#관련-용어)
   * [특징](#특징)
   * [종류](#종류)
   * [구현 2가지](#구현-2가지)
   * [탐색](#탐색)
8. [Tree](#tree)
   * [특징](#특징)
   * [종류](#종류)
   * [구현 방법](#구현-방법)
9. [Graph vs Tree](#graph-vs-tree)
10. [Heap](#heap)
    * [종류](#종류)
    * [구현](#구현)
11. [균형 트리](#균형-트리)
    * [AVL Tree](#avl-tree)
    * [Red-Black Tree](#red-black-tree)
    * [B Tree](#b-tree)
    * [B+ Tree](#btree)
    * [B Tree와 B+Tree의 공통점, 차이점](#b-tree와-btree의-공통점-차이점)

## Array vs LinkedList

### Array (배열)

- 논리적 저장 순서와 물리적 저장 순서가 일치한다.

- 인덱스로 해당 원소에 접근이 가능하다.

  ⇒ 인덱스만 알고 있다면 시간 복잡도 O(1)만에 해당 원소로 접근할 수 있다.

  ⇒ 즉, Random Access가 가능하다.

- 배열의 원소를 삭제할 경우, 삭제한 원소보다 큰 인덱스를 가지는 원소들을 옮겨줘야(Shift)하기 때문에 시간 복잡도 O(n)이 걸린다.

  삽입의 경우, 새로운 원소를 추가하고 모든 원소들의 인덱스를 1식 Shift 해줘야 하므로 시간 복잡도 O(n)이 걸린다.

  ⇒ 즉, 삭제 또는 삽입의 과정에서 해당 원소에 접근하여 작업을 완료한 뒤 Shift를 해줘야 하는 cost가 발생하기 때문에 O(n)의 시간복잡도를 갖는다.

- 제한적인 크기를 갖는다.

### LinkedList

- 자료의 주소 값으로 노드를 이용해 서로 연결되어 있는 구조를 갖는다.

- 삽입과 삭제의 경우, LinkedList가 Array보다 속도가 빠르다고 하지만 엄밀히 말하면 경우에 따라 다르다.

  ⇒ LinkedList 역시 삽입과 삭제를 위해서 해당 노드를 찾아가는 동안 O(n)의 시간 복잡도를 갖는다.

  ⇒ 만약, 중간 삽입이 없다면, 즉 맨 앞과 맨 뒤에 삽입한다면 시간 복잡도 O(1)

  ⇒ 삭제도 마찬가지. 중간 삭제가 없고 맨 앞과 맨 뒤에서만 삭제한다면 시간 복잡도 O(1)

- 원하는 값을 찾기 위해서 최소 한 번은 리스트를 순회해야 하므로 O(n)의 시간 복잡도를 갖는다.

- 트리의 근간이 되는 자료구조이다.

### Array와 LinkedList 차이점?

1. 데이터 접근 속도

   - Array는 인덱스를 사용해 빠르게 원소에 접근할 수 있다. Random Access를 지원한다. 시간 복잡도 O(1)로 빠르게 찾을 수 있다.
   - LinkedList는 순차 접근 방식을 사용한다. 특정 원소에 접근하기 위해서는 처음부터 원소에 도달할 때까지 순차적으로 검색하면서 찾는다. 시간 복잡도 O(N)

2. 데이터의 삽입 속도

   - Array의 경우 데이터를 중간이나 맨 앞에 삽입할 경우, 그 이후의 데이터를 한 칸 씩 미뤄야 하는 추가 과정과 시간이 소요된다. 데이터가 많을수록 비효율적이다.

     ⇒ 그렇기 때문에 LinkedList가 필요

   - LinkedList는 어느 곳에 삽입하던지 O(N)의 시간 복잡도를 갖는다. (중간 삽입이 없다면 O(1)의 시간 복잡도를 갖는다.)

     ⇒ 삽입할 위치를 찾고(O(N)), 삽입 연산을 진행하기 때문에 O(N)의 시간 복잡도를 갖는다. 그럼에도 Array보다 빠른 성능을 보인다.

   - 또, Array의 경우 데이터 삽입 시 모든 공간이 다 차버렸다면 새로운 메모리 공간을 할당 받지만, LinkedList는 그럴 필요가 없다. 추가할 때마다 동적으로 할당한다.

3. 데이터의 삭제 속도

   - Array는 데이터의 삭제의 경우 그 위치의 데이터를 삭제한 후, 전체적으로 Shift해줘야 한다. (O(N))
   - LinkedList의 경우 삭제할 원소를 찾기 위해서 O(N)의 시간 복잡도를 갖고 삭제를 한다. 결국 O(N)의 시간 복잡도를 갖는다. 하지만 Array보다 빠르게 삭제 연산을 수행한다.

4. 메모리 할당

   - Array에서 메모리는 Array가 선언되지 마자 Compile time에 할당되어 진다. 이것을 정적 메모리 할당이라고 한다.
   - LinkedList에서 메모리는 새로운 node가 추가될 때 Runtime에 할당되어진다. 이것은 동적 메모리 할당이라고 한다.

5. Size

   - Array의 size는 반드시 선언 시점에 지정되어 있어야 한다.
   - LinkedList의 size는 다양할 수 있다. node들이 추가될 때 Runtime시점에서 LinkedList의 size가 커질 수 있기 때문이다.

### 결론

- 삽입과 삭제가 빈번하다면 LinkedList를 사용하는 것이 더 좋다.
- 데이터의 접근하는 것이 중요하다면 Array를 사용하는 것이 더 좋다.

</br>

## ArrayList vs LinkedList

### ArrayList

- 내부적으로 데이터를 배열에서 관리하며, 데이터의 추가, 삭제를 위해서 임시 배열을 생성해 데이터를 복사하는 방법을 사용한다.
- 대량의 자료를 추가/삭제 하는 경우 그만큼 데이터의 복사가 많이 일어나게 되어 성능 저하가 발생한다.
- 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 존재해야 한다.
- 인덱스를 가지고 있어 한 번에 참조가 가능해 데이터 검색에 유리하다.

원소에 대해 빠르게 접근할 수 있을 뿐만 아니라, 원소들이 메모리에 연속으로 배치해 있어 CPU 캐시 효율도 더욱 높다.

### LinkedList

- 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있으면 된다.
- ArrayList와 달리 데이터의 추가/삭제 시, 불필요한 데이터의 복사가 없어 데이터의 추가, 삭제 시에 유리하다.
- 반면, 데이터 검색 시에는 처음부터 노드를 순회하기 때문에 성능상 불리하다.

### 데이터 검색, 삽입, 삭제 성능 비교

1. 검색
   - ArrayList : 인덱스 기반이기 때문에 O(1)의 시간 복잡도를 갖는다.
   - LinkedList : 검색 시 모든 요소를 순차적으로 탐색해야 하기 때문에 O(N)의 시간 복잡도를 갖는다.
2. 삽입, 삭제
   - ArrayList : 삽입, 삭제 이후 다른 데이터를 복사해야 하기 때문에 O(N)의 시간 복잡도를 갖는다. (가지고 있던 용량이 꽉 찼을 때, 용량이 기존의 1.5배를 늘린 새로운 배열에 기존 배열을 copy하는 것)
   - LinekdList : 이전 노드와 다음 노드를 참조하는 상태만 변경하면 되기 때문에 삽입, 삭제 시에 O(1)의 시간 복잡도를 갖는다.

</br>

## HashTable

### HashTable(해시테이블)이란?

(Key, Value)로 데이터를 저장하는 자료 구조

- 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문에 빠르게 데이터를 검색할 수 있는 자료 구조이다.

- 각각의 Key값에 해시 함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색하게 된다.

  ⇒ 여기서 실제 값이 저장되는 장소를 버킷 또는 슬롯 이라고 한다.

- 이러한 구조로 데이터를 저장하면 Key값으로 데이터를 찾을 때, 해시 함수를 1번만 수행하면 되므로 매우 빠르게 데이터를 저장/삭제/조회 할 수 있다.

  ⇒ 해시 테이블의 평균 시간 복잡도는 O(1)이다.

**:heavy_plus_sign: Hash 함수 (해시 함수)**

해시 함수에서 가장 중요한 것은 고유한 인덱스 값을 설정하는 것이다. 대표적인 해시 함수로는 아래의 3가지가 있다.

1. Division Method

   나눗셈을 이용하는 방법으로 입력값을 테이블의 크기로 나누어 계산한다.

   (주소 = 입력값 % 테이블의 크기)

   테이블의 크기를 소수로 정하고 2의 제곱수와 먼 값을 사용해야 효과가 좋다고 알려져 있다.

2. Digit Folding

   각 Key의 문자열을 ASCII코드로 바꾸고 값을 합한 데이터를 테이블 내의 주소로 사용하는 방법이다.

3. Multiplication Method

   숫자로 된 Key값 K와 0과 1사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 다음과 같은 계산을 해준다.

   h(k) = (kAmod1)*m

4. Universal Hashing

   다수의 해시 함수를 만들어 집합 H에 넣어 두고, 무작위로 해시 함수를 선택해 해시 값을 만드는 기법이다.

### Hash값이 충돌하는 경우(분리연결법, 개방 주소법, Resizing)

해시 테이블에서는 충돌에 의한 문제를 **분리 연결법**과 **개방 주소법** 크게 2가지로 해결하고 있다.

1. **분리 연결법 (Separate Chaining)**

   동일한 버킷의 데이터에 대해 자료구조를 활용해 추가 메모리를 사용하여 다음 데이터의 주소를 저장하는 것이다.

   (⇒ 동일한 버킷으로 접근한다면, 데이터들을 연결해서 관리해준다.)

   (➕ 실제로 Java8의 Hashtable은 Self-Balancing Binary Search Tree 자료구조를 사용해 Chaning방식을 구현하였다. JDK 내부에서 사용하는 충돌 처리 방식)

   - 이러한 Chaining 방식은 해시 테이블의 확장이 필요 없고, 간단하게 구현이 가능하며, 손쉽게 삭제할 수 있다는 장점이 있다.
   - LinkedList 구조를 사용하기 때문에 추가 데이터 수 제약이 적은 편이다. 하지만, 데이터의 수가 많아지면 동일한 버킷에 Chaining되는 데이터가 많아지며 그에 따라 캐시의 효율성이 감소한다는 단점이 있다.

2. **개방 주소법 (Open Addressing)**

   추가적인 메모리를 사용하는 Chaining 방식과 다르게 비어있는 해시 테이블의 공간을 활용하는 방법이다.

   Separating Chaining 방식에 비해 적은 메모리를 사용한다.

   Open Addressing을 구현하기 위한 대표적인 방법으로는 3가지 방식이 존재한다.

   1. Linear Probing(선형 탐사)

      현재의 버킷 index로부터 고정폭만큼씩 이동하여 차례대로 검색해 비어있는 버킷에 데이터를 저장한다.

   2. Queadratic Probing(제곱 탐사)

      해시의 저장 순서 폭을 제곱으로 저장하는 방식이다.

      예를 들어, 처음 충돌이 발생한 경우에는 1만큼 이동하고, 그 다음 계속 충돌이 발생하면 2^2, 3^2 칸씩 옮기는 방식이다.

   3. Double Hashing Probing(이중 해싱)

      해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식이다.

      해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다.

   Open Addressing에서 데이터를 삭제하면 삭제된 공간은 Dummy Space로 활용되는데, 그렇기 때문에 HashTable을 재정리해주는 작업이 필요하다고 한다.

3. **Resizing**

   저장 공간이 일정 수준 채워지면 Separating Chaining의 경우 성능 향상을 위해 Open Addressing의 경우 배열 크기 확장을 위해 Resizing한다.

   보통 2배로 확장하며, 확장 임계점은 현재 데이터 개수가 Hash bucket 개수의 75%가 될 때이다.

### 해시테이블의 시간 복잡도

각각의 Key값은 해시 함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로, 평균 O(1)의 시간 복잡도로 데이터를 조회할 수 있다.

하지만, 데이터의 충돌이 발생한 경우 Chaining에 연결된 리스트들까지 검색을 해야하므로 O(N)까지 시간 복잡도가 증가할 수 있다.

충돌을 방지하는 방법들은 데이터의 규칙성(클러스터링)을 방지하기 위한 방식이지만, 공간을 많이 사용한다는 치명적인 단점이 있다.

만약, 테이블이 꽉 차있는 경우라면 테이블을 확장해주어야 하는데, 이는 매우 심각한 성능 저하를 불러오기 때문에 가급적이면 확장을 하지 않도록 테이블을 설계해주어야 한다.

( ⇒ 통계적으로, 해시 테이블의 공간 사용률이 70~80% 정도가 되면 해시의 충돌이 빈번하게 발생하여 성능이 저하되기 시작한다고 한다.)

➕ 또한 해시 테이블에서 자주 사용하게 되는 데이터를 Cache에 적용하면 효율을 높일 수 있다. 자주 hit하게 되는 데이터를 캐시에서 바로 찾음으로써 해시 테이블의 성능을 향상시킬 수 있다.

### HashTable의 장점

- 적은 리소스로 많은 데이터를 효율적으로 관리 가능하다.

- 배열의 인덱스를 사용하기 때문에 빠른 검색, 삽입, 삭제 ⇒ O(1)

  (Hashtable의 경우 인덱스는 데이터의 고유 위치이기 때문에 삽입, 삭제 시 다른 데이터를 이동할 필요가 없어 삽입, 삭제도 빠른 속도로 가능하다.)

- Key와 Hash에 연관성이 없어 보안에 유리하다.

- 데이터 캐싱에 많이 사용된다.

  get, put기능에 캐시 로직 추가 시, 자주 hit하는 데이터 바로 검색 가능

- 중복 제거에 유용하다.

### HashTable 단점

- 충돌 발생 가능성
- 공간 복잡도 증가
- 순서 무시
- 해시 함수에 의존

### Java의 HashMap과 Hashtable의 차이

그 차이는 동기화 지원 여부에 있다.

해시테이블의 put에는 `synchronized` 키워드가 붙어있는데, 이것은 병렬 프로그래밍을 할 때 동기화를 지원해준다는 것을 의미한다. 이것은 해당 함수를 처리하는 시간이 조금 지연됨을 의미한다.

그렇기 때문에, 병렬 처리를 하면서 자원의 동기화를 고려해야 하는 상황이라면 `Hashtable`을 사용해야 하며, 병렬 처리를 하지 않거나 자원의 동기화를 고려하지 않는 상황이라면 `HashMap`을 사용하면 된다.

</br>

## Stack

한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out)형식의 자료 구조이다.

- 배열과 달리, 스택은 상수 시간에 i번째 항목에 접근할 수 없다.
- 하지만, 스택에서 데이터를 추가하거나 삭제하는 연산은 상수 시간에 가능하다.
- 배여러럼 원소들을 하나씩 옆으로 밀어 줄 필요가 없다.

**연산**

* pop() : 스택에서 가장 위에 있는 항목을 제거한다.

* push(item) : item 하나를 스택의 가장 윗 부분에 추가한다.

* peek() : 스택의 가장 위에 있는 항목을 반환한다.

* isEmpty() : 스택이 비어있을 때 true를 반환한다.

**구현**

연결 리스트로 구현할 수 있다. 연결 리스트의 같은 방향에서 아이템을 추가하고 삭제하도록 구현한다.

<br>

## Queue

먼저 집어 넣은 데이터가 먼저 나오는 FIFO(First In First Out) 구조로 저장하는 형식이다.

**연산**

* add(item) : item을 리스트의 끝 부분에 추가한다.

* remove() : 리스트의 첫 번째 항목을 제거한다.

* peek() : 큐에서 가장 위에 있는 항목을 반환한다.

* isEmpty() : 큐가 비어있을 때에 true를 반환한다.

**구현**

연결 리스트로 구현할 수 있다. 연결 리스트의 반대 방향에서 항목을 추가하거나 제거하도록 구현한다.

**:heavy_plus_sign: Java 라이브러리 Queue 관련 메소드**

두 가지 형태의 메소드

1. 수행이 실패했을 때 *exception* 을 발생

   `add(e)` , `element()`, `remove()`

2. 수행이 실패했을 때 *null* 또는 *false* 를 반환

   `offer(e)`, `peek()`, `poll()`

* `add(e)`, `offer(e)` : 해당 아이템을 Queue에 삽입

* `element()`, `peek()` : Queue의 Head에 있는 아이템을 삭제하지 않고 반환

* `remove()` , `poll()` : Queue의 Head에 있는 아이템을 삭제하고 반환

### 스택으로 큐 구현
+ 스택으로 큐를 구현하기 위해서는 스택 2개가 필요하다.

+ push 할 때는 in_stack에 차례로 값을 push 한다. 

  <img src="https://user-images.githubusercontent.com/33089715/120882514-61a7d780-c613-11eb-9902-bc9da4547674.png" width = "300">
+ pop 할 때는 out_stack가 비어있으면 in_stack에 있는 값들을 차례대로 pop 하고, out_stack에 push 해준다. 

  <img src="https://user-images.githubusercontent.com/33089715/120882521-6b313f80-c613-11eb-87ce-fd2adadcbba0.png" width = "300">

  + push 가 끝난 후 pop 하면 제일 먼저 들어간 값이 나오게 된다.

    <img src="https://user-images.githubusercontent.com/33089715/120882531-74baa780-c613-11eb-9a54-f8ab9b7b9c8d.png" width = "300">
  
### 큐로 스택 구현
+ 스택에 push 하는 경우에 큐에 값을 넣는다.

   <img src="https://user-images.githubusercontent.com/33089715/120882793-e6472580-c614-11eb-9962-0cdc44a35d4d.png" width = "300">
  
+ 처음 넣은 값을 제외하고 나머지 값들을 모두 큐에서 pop해서 다시 push 한다.

  <img src="https://user-images.githubusercontent.com/33089715/120882804-ef37f700-c614-11eb-9b16-8c4ba3a2befe.png" width = "300">
+ 완료 되면 큐의 마지막에 넣은 값이 제일 앞에 있게 된다. top()이나 pop() 메소드를 호출할 때 큐의 첫 번째 값을 참조하면 된다.

  <img src="https://user-images.githubusercontent.com/33089715/120882808-f4954180-c614-11eb-8f41-5c1bf86a25ec.png" width = "300">

</br>

## Priority Queue

top, pop에서 추출되는 원소는 제일 먼저 들어왔던게 아니라 현재 우선순위 큐 안에서 제일 우선순위가 높은 원소이다.

- 데이터들이 우선순위를 가지고 있고 우선순위가 높은 데이터가 먼저 나가게 됨
- 부여되는 우선순위에 따라 스택이나 큐로 동작 가능
- 배열, 연결리스트, 힙으로 구현가능
    - 보통 힙으로 구현한다.
- 우선 순위 큐의 종류
    - 최소 우선순위 큐 : 가장 우선순위가 낮은 요소를 먼저 삭제
    - 최대 우선순위 큐 : 가장 우선순위가 높은 요소를 먼저 삭제


### 힙으로 구현하는 이유?

1) 만일 **배열로 구현**한다고 가정하자. 우선순위가 높은 순서대로 배열의 가장 앞부분 부터 넣는다면, 우선순위가 높은 데이터를 반환하는 것은 맨 앞의 인덱스를 바로 이용하면 되므로 어렵지 않다.

    하지만 우선순위가 중간인 것이 들어가야 하는 삽입 과정에서는 뒤의 데이터까지 인덱스를 모두 한 칸 씩 뒤로 밀어야 하는 단점이 있다.

    최악의 경우 삽입해야 하는 위치를 찾기 위해 모든 인덱스를 탐색하야 한다. 즉 이 때의 시간 복잡도는 자료가 n 개라고 할 때 O(n)이 된다.

    → 배열로 구현 시 시간 복잡도 : 삭제는 O(1), 삽입은 O(n)

2) 만일 **연결리스트로 구현**한다고 가정하자. 이 또한 우선순위가 높은 순서대로 연결을 시키면, 우선 순위가 높은 데이터의 반환은 배열과 마찬가지로 쉽다.

    하지만 연결리스트 또한 삽입의 과정에 있어 배열과 마찬가지로 그 위치를 찾아야 한다. 최악의 경우 맨 끝에까지 가게 된다.

    → 연결리스트로 구현 시 시간 복잡도 : 삭제 O(1), 삽입 O(n)

3) **힙으로 구현**한다고 가정하자. 힙의 경우 삭제나 삽입 과정에서 모두 부모와 자식 간의 비교만 계속 이루어 진다.

    즉 이진트리의 높이가 하나 증가할 때마다 저장 가능한 자료의 개수는 2배 증가하며, 비교 연산 횟소는 1회 증가한다. 즉 삽입과 삭제 모두 최악의 경우에는 O(log_2 N) 의 시간 복잡도를 가진다.

    → 힙으로 구현시 시간 복잡도 : 삭제 O(log_2 N),삽입 O(log_2 N)

## Graph

단순히 노드와 그 노드를 연결하는 간선을 하나로 모아 놓은 자료구조이다. 

⇒ 즉, 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조이다.

### 관련 용어

- 정점(Vertex): 위치라는 개념. Node라고도 부른다.

- 간선(Edge): 위치 간의 관계. 즉, 노드를 연결하는 선. link, branch라고도 부른다.

- 인접 정점(Adjacent vertex): 간선에 의해 직접 연결된 정점

- 정점의 차수(degree): 무방향 그래프에서 하나의 정점에 인접한 정점의 수

  `무방향 그래프에 존재하는 정점의 모든 차수의 합 = 그래프의 간선 수의 2배`

- 진입 차수(in-degree): 방향 그래프에서 외부에서 오는 간선의 수(내차수라고도 부른다)

- 진출 차수(out-degree): 방향 그래프에서 외부로 향하는 간선의 수 (외차수라고도 부른다.)

- 경로 길이(path length): 경로를 구성하는 데에 사용된 간선의 수

- 단순 경로(simple path): 경로 중에서 반복되는 정점이 없는 경우

- 사이클(cycle): 단순 경로의 시작 정점과 종료 정점이 동일한 경우

### 특징

- 그래프는 네트워크 모델이다.

- 2개 이상의 경로가 가능하다.

  즉, 노드들 사이에 무방향/방향에서 양방향 경로를 가질 수 있다.

- self-loop 뿐 아니라 loop/circuit 모두 가능하다.

- 루트 노드라는 개념이 없다.

- 부모-자식 관계라는 개념이 없다.

- 순회는 DFS나 BFS로 이루어진다.

- 그래프는 순환(cyclic) 또는 비순환(Acyclic)이다.

- 크게 방향 그래프와 무방향 그래프가 있다.

- 간선의 유무는 그래프에 따라 다르다.

### 종류

1. 무방향 그래프 vs 방향 그래프

   - 무방향 그래프 (Undirected Graph)

     간선을 통해서 양 방향으로 갈 수 있다.

     정점 A와 정점 B를 연결하는 간선은 (A,B)와 같이 정점의 쌍으로 표현한다.

     (A,B) == (B,A)

   - 방향 그래프 (Directed Graph)

     간선에 방향성이 존재하는 그래프

     A→B로만 갈 수 있는 간선은 <A,B>로 표시한다.

     <A,B> ≠ <B,A>

2. 가중치 그래프

   간선에 비용이나 가중치가 할당된 그래프.

   네트워크(Network)라고도 한다

3. 연결 그래프 vs 비연결 그래프

   - 연결 그래프 (Connected Graph)

     무방향 그래프에 있는 모든 정점쌍에 대해서 항상 경로가 존재하는 경우

     예) 트리(사이클을 가지지 않는 연결 그래프)

   - 비연결 그래프 (Disconnected Graph)

     무방향 그래프에서 특정 정점쌍 사이에 경로가 존재하지 않는 경우

4. 사이클 vs 비순환 그래프

   - 사이클

     단순 경로의 시작 정점과 종료 정점이 동일한 경우

     (단순 경로: 경로 중에서 반복되는 정점이 없는 경우)

   - 비순환 그래프

     사이클이 없는 그래프

5. 완전 그래프

   그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프

   무방향 완전 그래프 ⇒ 정점 수 n이면 간선의 수는 n(n-1)/2

### 구현 2가지

1. **인접 리스트 (Adjacency List)**

   인접 리스트로 그래프를 표현하는 것이 가장 일반적인 방법이다.

   모든 정점을 인접 리스트에 저장한다. 즉, 각각의 정점에 인접한 정점들을 리스트로 표시한 것이다.

2. **인접 행렬 (Adjacency Matrix)**

   인접 행렬은 NxN Boolean Matrix로써 `matrix[i][j]`가 `true`라면 i→j로의 간선이 있다는 뜻이다.

   - 정수 행렬을 사용할 수도 있다,

   - 인접 리스트를 사용한 그래프 알고리즘들 또한 인접 행렬에서도 사용이 가능하다.

     하지만 인접 행렬은 조금 효율성이 떨어진다.

     인접 리스트는 어떤 노드에 인접한 노드들을 쉽게 찾을 수 있지만, 인접 행렬에서는 인접한 노드를 찾기 위해서는 모든 노드를 전부 순회해야 한다.

:heavy_plus_sign:**선택 방법**

- 인접 리스트

  그래프 내에 적은 숫자의 간선만을 가지는 *희소 그래프(Sparse Graph)* 의 경우.

  **장점**

  - 어떤 노드에 인접한 노드들을 쉽게 찾을 수 있다.
  - 그래프에 존재하는 모든 간선의 수는 O(N+E)안에 알 수 있다.

  **단점**

  - 정점 i의 리스트에 있는 노드의 수 즉, 정점 차수 만큼의 시간이 필요하다.

- 인접 행렬

  그래프에 간선이 많이 존재하는 *밀집 그래프(Dense Graph)* 의 경우

  **장점**

  - 두 정점을 연결하는 간선의 존재 여부를 O(1) 안에 알 수 있다.
  - 정점의 차수는 O(N) 안에 알 수 있다.

  **단점**

  - 어떤 노드에 인접한 노드를 찾기 위해서는 모든 노드를 전부 순회해야 한다.
  - 그래프에 존재하는 모든 간선의 수는 O(N^2)안에 알 수 있다.

### 탐색

일반적인 방법 2가지

1. **깊이 우선 탐색 (DFS, Depth First Search)**

   임의의 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법

   - 모든 노드를 방문하고자 하는 경우 이 방법을 선택한다.
   - 너비 우선 탐색보다 좀 더 간단하다.

2. **너비 우선 탐색 (BFS, Breadth First Search)**

   임의의 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법

   - 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 선택한다.

</br>

## Tree

노드로 이루어진 자료구조

- 트리는 하나의 루트 노드를 갖는다.
- 루트 노드는 0개 이상의 자식 노드를 가지고 있다.
- 그 자식 노드 또한 0개 이상의 자식 노드를 가지고 있고, 이는 반복적으로 정의된다.

### 특징

- 트리에는 사이클이 존재할 수 없다.

- 노드들은 특정 순서로 나열될 수도 있고, 그럴 수 없을 수도 있다.

- 비선형 자료구조로, 계층적 관계를 표현한다. (계층모델이다.)

- **그래프의 한 종류**이다.

  **사이클이 없는 하나의 연결 그래프**

  또는 **DAG(Directed Acyclic Graph, 방향성이 있는 비순환 그래프)의 한 종류**

- 노드가 N개인 트리는 항상 N-1개의 간선을 가진다.
- 루트에서 어떤 노드로 가는 경로는 유일하다.
  - 임의의 두 노드 간의 경로도 유일하다.
- 한 개의 루트 노드만이 존재하며, 모든 자식 노드는 한 개의 부모 노드만을 가진다.
- 순회는 Pre-order, In-order, Post-order로 이루어진다.
- 이진 트리, 이진 탐색 트리, 균형 트리(AVL트리, red-black 트리), 이진힙(최대힙, 최소힙)등이 있다.

### 종류

1. 이진 트리 (Binary Tree)

   각 노드가 최대 두 개의 자식을 갖는 트리.

   모든 트리가 이진 트리는 아니다.

   **이진 트리 순회**

   - 중위 순회(in-order)

     Left → Root → Right

   - 전위 순회(pre-order)

     Root → Left → Right

   - 후위 순회(post-order)

     Left → Right → Root

2. 이진 탐색 트리 (Binary Search Tree)

   모든 노드가 다음과 같은 특정 순서를 따르는 속성이 있는 이진 트리

   모든 왼쪽 자식들 ≤ n < 모든 오른쪽 자식들 (모든 노드 n에 대해서 반드시 참)

3. 균형 트리

   O(logN) 시간에 insert와 find를 할 수 있을 정도로 균형이 잘 잡혀있는 경우

   예) Red-Black Tree, AVL 트리

4. 전 이진 트리 vs 완전 이진 트리 vs 포화 이진 트리

   <img src="https://user-images.githubusercontent.com/33208360/116958381-5e988f00-acd5-11eb-95e3-a6a4ae9adb43.png" alt="image" style="zoom:67%;" />

   - 전 이진 트리 (Full Binary Tree 또는 Strictly Binary Tree)

     모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리

   - 완전 이진 트리 (Complete Binary Tree)

     트리의 모든 높이에서 노드가 꽉 차있는 이진 트리. 즉, 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있다.

     - 마지막 레벨은 꽉 차 있지 않아도 되지만, 노드가 왼쪽에서 오른쪽으로 채워져야 한다.
     - 배열을 사용해 효율적으로 표현이 가능하다.

   - 포화 이진 트리 (Perfect Binary Tree)

     전 이진 트리이면서 완전 이진 트리인 경우

     모든 말단 노드는 같은 높이에 있어야 하며, 마지막 단계에서 노드의 개수가 최대가 되어야 한다.

     모든 내부 노드가 두 개의 자식 노드를 가진다.

     모든 말단 노드가 동일한 깊이 또는 레벨을 갖는다.

     노드의 개수가 정확히 (2^k-1)개여야 한다. (k: 트리의 높이)

5. 이진 힙 (최소 힙, 최대 힙)

   - 최소힙 (Min Heap)

     트리의 마지막 단계에서 오른쪽 부분을 뺀 나머지 부분이 가득 채워져 있는 완전 이진 트리이며, 각 노드의 원소가 자식들의 원소보다 작다.

     즉, `부모 노드 ≥ 자식노드`인 완전 이진 트리

     가장 큰 값은 루트 노드이다.

     N개가 힙에 있으면 높이는 log(N)이다.

   - 최대힙 (Max Heap)

     원소가 내림차순으로 정렬되어 있다는 점만 최소힙과 다르다.

     각 노드의 원소가 자식들의 원소보다 크다.

     `부모 노드 <= 자식노드`인 완전 이진 트리

6. 트라이 (Trie)

   n-차 트리의 변종

   각 노드에 문자를 저장하는 자료구조

   ⇒ 따라서 트리를 아래쪽으로 순회하면 단어 하나가 나온다.

   접두사를 빠르게 찾아보기 위한 흔한 방식으로, 모든 언어를 트라이에 저장해 놓는 방식이 있다.

   유효한 단어 집합을 이용하는 많은 문제들은 트라이를 통해 최적화할 수 있다.

### 구현 방법

기본적으로 트리는 그래프의 한 종류이므로 그래프의 구현 방법으로 구현할 수 있다.

1. 인접 배열 이용
2. 인접 리스트 이용

</br>

## Graph vs Tree

<img src="https://user-images.githubusercontent.com/33208360/116958586-1cbc1880-acd6-11eb-9813-4757f03c0528.png" alt="image" style="zoom:67%;" />

</br>

## Heap

- 완전 이진 트리의 일종으로, 우선 순위 큐를 위해 만들어진 자료 구조이다.

- 여러 개의 값들 중 최댓값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조이다.

- 힙은 일종의 반정렬 상태(느슨한 정렬 상태)를 유지한다.

  ⇒ 큰 값이 상위 레벨에 있고, 작은 값이 하위 레벨에 있다는 정도

- 중복된 값을 허용한다. (이진 탐색 트리에서는 중복된 값을 허용하지 않는다.)

### 종류

- **최대 힙**

  부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리

- **최소 힙**

  부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리

### 구현

힙을 저장하는 표준적인 자료 구조는 **배열**이다.

⇒ 구현을 쉽게 하기 위해 배열의 0번 인덱스는 사용하지 않는다.

- 부모 노드와 자식노드의 관계
  - 왼쪽 자식의 인덱스 = (부모 인덱스) * 2
  - 오른쪽 자식의 인덱스 = (부모 인덱스) * 2 + 1
  - 부모 인덱스 = (자식 인덱스) / 2

**삽입**

1. 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입한다.
2. 새로운 노드를 부모 노드들과 교환해서 힙의 성질을 만족시킨다.

**삭제**

1. 최대 힙에서 최댓값을 루트 노드이므로 루트 노드가 삭제된다. (최소 힙에서 최솟값은 루트)
2. 삭제된 루트 노드에는 힙의 마지막 노드를 가져온다.
3. 힙을 재구성한다.

</br>

## 균형 트리

일반적인 이진 검색 트리에서는 트리 구조가 한 쪽으로 치우쳐지는 경우가 발생할 수 있다. 이진 검색 트리의 평균 검색 속도는 O(logN)이지만, 한 쪽으로 치우쳐진 경우에는 검색 속도가 O(N)까지 저하될 수 있다.

⇒ 이를 방지하기 위해 리벨런싱 작업을 수행하는 자료 구조로 AVL Tree, B-Tree, Red Black Tree가 있다.

<br>

## AVL Tree

이진 탐색 트리이면서 동시에 균형을 유지하고 있다.

​	⇒ **BF(Balance Factor)**를 통해 균형을 맞춘다. BF값을 통한 균형은 rotation을 통해 이루어진다.

- 왼쪽 서브 트리의 높이에서 오른쪽 서브 트리의 높이를 뺀 값이 그 노드의 BF가 된다.

* 모든 노드의 왼쪽과 오른쪽 서브트리의 높이 차이가 1이하이다.

  ⇒ 이렇게 균형을 유지하고 있기 때문에 이진 검색 시의 효율성을 보장할 수 있다.

* 좌우 높이 차가 1보다 커지면 균형이 무너진 것.

  ⇒ 균형이 무너진 유형에는 4가지가 있다.

  <img src="https://user-images.githubusercontent.com/33208360/116958913-0a8eaa00-acd7-11eb-9644-9c16ecac634f.png" alt="image" style="zoom: 50%;" />

  * LL (Left-Left)

    왼쪽의 높이가 오른쪽의 높이보다 큰 것 (2이상)	⇒ 우회전 한 번

    <img src="https://user-images.githubusercontent.com/33208360/116959042-5f322500-acd7-11eb-8cf9-4a80494bbd5e.png" alt="image" style="zoom:50%;" />

  * RR (Right-Right)

    오른쪽의 높이가 왼쪽의 높이보다 큰 것 (2이상)	⇒ 좌회전 한 번

    <img src="https://user-images.githubusercontent.com/33208360/116959077-7bce5d00-acd7-11eb-94cf-06ea61c6e778.png" alt="image" style="zoom:50%;" />

  * LR (Left - Right)

    두 번째 노드를 좌회전 한 후, 전체 노드를 우회전한다.

    <img src="https://user-images.githubusercontent.com/33208360/116959117-930d4a80-acd7-11eb-88d9-95040c893ec2.png" alt="image" style="zoom:50%;" />

  * RL (Right-Left)

    두 번째 노드를 우회전 한 번 후, 전체 노드를 좌회전 한다.

    <img src="https://user-images.githubusercontent.com/33208360/116959141-a3252a00-acd7-11eb-9150-0b5a5a6c7a4a.png" alt="image" style="zoom:50%;" />

> https://velog.io/@soonbee/AVL-Tree%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90

<br>

## Red-Balck Tree

이진 탐색 트리이다.

<img src="https://user-images.githubusercontent.com/33208360/116959205-dbc50380-acd7-11eb-930d-d8c91f0454c7.png" alt="image" style="zoom:50%;" />

### 조건

(트리의 모든 노드는 레드 or 블랙)

1. 루트 노드는 무조건 블랙

2. 모든 리프노드는 블랙

3. **루트 노드에서 리프 노드까지 블랙의 갯수는 항상 같다. ⇒ 이 조건이 레드 블랙 트리의 균형을 책임진다.**

   위의 예시)

   리프 노드 6은 블랙 노드 1을

   리프 노드 22는 블랙 노드 25를

   리프 노드 27은 블랙 노드 25를

4. 레드 노드의 자식은 모두 블랙, 블랙 노드의 자식은 상관 없음

   ⇒ 레드는 중복될 수 없으니 반드시 레드와 레드 사이엔 하나의 블랙 노드를 끼게 되고, 이는 곧 레드 블랙 트리의 총 깊이가 된다.

### 동작

- 이진 탐색 트리이기 때문에 탐색, 삽입, 삭제 연산으로 동작한다.
- 탐색 연산은 변경할 필요가 없으나 삽입, 삭제 연산의 경우 균형을 맞춰주는 동작이 필요하다.

### 연산 - Restructuring, Recoloring

자신(Z)과 부모 노드(V)가 레드라면, (레드는 중복될 수 없으므로 연산으로 처리해주어야 함)

1. **삼촌 노드(W)가 블랙일 때 또는 삼촌 노드가 null일 때 → Restructuring(Rotation)**

   <img src="https://user-images.githubusercontent.com/33208360/116959415-8e956180-acd8-11eb-9edf-a540e3e36d7d.png" alt="image" style="zoom:33%;" />

   1) 나(Z)와 부모(V), 부모의 부모를 오름차순으로 정렬한다.

   2) 무조건 가운데 있는 값을 부모로 만들고, 나머지 둘을 자식으로 만든다.

   3) 올라간 가운데 있는 값을 블랙으로 만들고 두 자식을 레드로 만든다.

2. **삼촌 노드(W)가 레드일 때 → Recoloring**

   <img src="https://user-images.githubusercontent.com/33208360/116959482-b7b5f200-acd8-11eb-8028-5ef77ef627c4.png" alt="image" style="zoom:33%;" />

   1) 삽입된 노드(Z)의 부모와 삼촌(W)을 블랙으로 하고, 부모의 부모를 레드로 만든다.

   2) 부모의 부모가 Root가 아니었을 시, 더블 레드가 다시 발생 가능

   ​	(이때 Root라면, "Root는 블랙"이라는 규칙에 위배되므로 다시 검정으로 변경한다.)

## AVL Tree와 Red Black Tree 차이?

- AVL Tree가 Red Black Tree보다 빠른 Search를 제공
    - AVL Tree가 더 엄격한 Balanced를 유지
- Red Black Tree은 AVL Tree보다 빠른 삽입과 제거
    - Red Black Tree보다 Balanced를 느슨하게 유지하고 있기 
- Red Black Trees는 대부분의 언어의 map, multimap, multiset에서 사용하고 있다.
- AVL tree는 조회에 속도가 중요한 Database에서 사용하고 있다.
</br>

## B-Tree

> https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree

이진 트리에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 밸런스를 맞추는 트리

- 정렬된 순서를 보장하고, 멀티 레벨 인덱싱을 통해 빠른 검색을 할 수 있기 때문에 DB에서 사용하는 자료구조 중 한 종류이다.

- 실제 DB에서는 B Tree에서 발전한 B+ Tree를 사용한다.

  

이진 트리와 다르게 하나의 노드에 많은 수의 정보를 가지고 있을 수 있다.

최대 M개의 자식을 가질 수 있는 B Tree를 M차 B Tree라고 한다.

- 노드는 최대 M개부터 M/2개 까지의 자식을 가질 수 있다.
- 노드에는 최대 M-1개부터 M/2-1개의 키가 포함될 수 있다.
- 노드의 키가 x개라면 자식의 수는 x+1이다.
- 최소 차수는 자식 수의 하한값을 의미하며, 최소 차수가 t라면 M = 2t -1을 만족한다.

예) 차수가 3인 B-Tree

<img src="https://user-images.githubusercontent.com/33208360/116961281-e4b8d380-acdd-11eb-8499-e7a233b915b3.png" alt="image" style="zoom: 50%;" />

* 파란색 : 각 노드의 key
* 빨간색 : 자식 노드를 가리키는 포인터

=> key들은 노드 안에서 항상 정렬된 값을 가지며, 이진 검색 트리처럼 각 key들의 왼쪽 자식들은 항상 key보다 작은 값을, 오른쪽은 큰 값을 가진다.

### key 검색 과정

루트 노드에서 시작해 하향식으로 검색을 수행한다. 검색하고자 하는 key를 k라고 했을 때, 검색과정이다.

1. 루트 노드에서 시작하여 key들을 순회하며 검사.

   1. 만일 k와 같은 key를 찾았다면 검색을 종료

   2. 검색하는 값과 key들의 대소 관계를 비교

      어떠한 key들 사이에 k가 들어간다면 해당 key들 사이의 자식노드로 내려간다.

2. 해당 과정을 리프노드에 도달할 때까지 반복

   만일 리프노드에도 k와 같은 key가 없다면 검색 실패

### key 삽입 과정

key를 삽입하기 위해

1. 요소 삽입에 적절한 리프 노드를 검색 ⇒ 하향식
2. 필요한 경우 노드를 분할 ⇒ 상향식



삽입하고자 하는 값을 k로 했을 때 삽입과정이다.

1. 트리가 비어있으면 루트 노드를 할당하고 k를 삽입한다.

   만일 루트 노드가 가득 찼다면, 노드를 분할하고 리프노드가 생성된다.

2. 이후부터는 삽입하기에 적절한 리프노드를 찾아 k를 삽입

   삽입 위치는 노드의 key값과 k값을 검색 연산과 동일한 방법으로 비교하며 찾는다.

**:heavy_plus_sign: 분할 여부에 따라**

* **Case 1) 분할이 일어나지 않는 경우**

  리프 노드가 가득 차지 않았다면, 오름차순으로 k를 삽입한다.

* **Case 2) 분할이 일어나는 경우**

  만일 리프노드에 key노드가 가득 찬 경우, 노드를 분할해야 한다.

  1) 오름차순으로 요소를 삽입 -> 노드가 담을 수 있는 최대 key 개수를 초과하게 된다.

  2) 중앙값에서 분할을 수행

  ​	중앙값은 부모 노드로 병합하거나 새로 생성됨

  ​	왼쪽 key들은 왼쪽 자식으로, 오른쪽 key들은 오른쪽 자식으로 분할된다.

  3) 부모 노드를 검사해서 또 다시 가득 찼다면, 다시 부모 노드에서 위 과정을 반복한다.

### key 삭제 과정

요소를 삭제하기 위해서는

1. 삭제할 키가 있는 노드를 검색
2. 키 삭제
3. 필요한 경우, 트리 균형 조정

> `inorder predecessor` : 노드의 왼쪽 자손에서 가장 큰 key
>
> `inorder successor` : 노드의 오른쪽 자손에서 가장 작은 key

* **Case 1)  삭제할 Key가 리프에 있는 경우**
  * 현재 노드의 key 개수가 최소 key 개수보다 크다면,

    다른 노드들에 영향 없이 해당 key를 단순 삭제한다.

  * 현재 노드가 최소 key개수이고, 왼쪽 또는 오른쪽 형제 노드의 key가 최소 key개수 이상이라면,

    1) 해당 노드를 부모 key값으로 대체

    2) 최소 키 개수 이상의 key를 가진 형제 노드가 왼쪽 형제라면 가장 큰 값을, 오른쪽 형제라면 가장 작은 값을 부모 key로 대체한다.

  * 왼쪽, 오른쪽 형제 노드의 key가 최소 key 개수이고, 부모 노드의 key가 최소 개수 이상이면,

    1) k를 삭제한 후, 부모 key를 k의 형제노드와 병합한다.

    2) 부모 노드의 key 개수를 하나 줄이고, 자식 수 역시 하나를 줄여 B-Tree를 유지한다.

  * 자신과 형제, 부모 노드의 key개수가 모두 최소 key 개수라면,

    부모 노드를 루트 노드로 한 서브트리의 높이가 줄어드는 경우이기 때문에 재구조화의 과정이 일어난다.

    => 부모 노드의 key 개수를 하나 줄이고, 자식 수 역시 하나를 줄여 B-tree를 유지한다.

* **Case 2) 삭제할 key가 내부 노드에 있고, 노드나 자식에 key가 최소 key개수보다 많을 경우**

  1) 현재 노드의 inorder predecessor 또는 inorder successor 와 k의 자리를 바꾼다.

  2) 리프 노드의 k를 삭제하게 되면, 리프 노드가 삭제되었을 때의 조건으로 변한다. 삭제한 리프노드에 대해서 Case1) 조건으로 이동한다.

* **Case 3) 삭제할 key k가 내부 노드에 있고, 노드에 key 개수가 최소 key개수만큼, 노드의 자식 key 개수도 모두 최소 key개수인 경우**

  삭제할 key k가 있는 노드도 최소, 자식 노드들도 최소 key개수를 가지므로 k를 삭제하면 트리의 높이가 줄어들어 재구조화가 일어난다.

  1) k를 삭제하고, k의 양쪽 자식을 병합하여 하나의 노드로 만든다.

  2) k의 부모 key를 인접한 형제 노드에 붙인다. 이후, 이전에 병합했던 노드를 자식 노드로 설정한다.

  3) 해당 과정을 수행했을 때 부모 노드의 개수에 따라 이후 수행과정이 달라진다.

  * 만일 새로 구성된 인접 형제 노드의 key가 최대 key  개수를 넘어갔다면,

    삽입 연산의 노드 분할 과정을 수행한다.

  * 만일 인접 형제 노드가 새로 구성되더라도 원래 k의 부모 노드가 최소 key의 개수보다 작아진다면,

    부모 노드에 대해 2번과정부터 다시 수행한다.

</br>

## B+Tree

>https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Plus-Tree

동작 방식은 B-Tree와 굉장히 유사하지만, 리프 노드는 연결리스트의 형태를 띄어 선형 검색이 가능하다는 차이점이 있다.

=> 이러한 특징 때문에 굉장히 작은 시간 복잡도에 검색을 수행할 수 있다.

* 실제 DB의 인덱싱은 B+Tree로 이루어져있다.

  (인덱싱: 어떤 자료를 찾는데에 key값을 이용해 효과적으로 찾을 수 있는 기능이다.)

### B트리와 B+트리의 차이점

1. B+트리는 모든 key, data가 리프 노드에 모여있다.

   B트리는 리프노드가 아닌 각자 key마다 data를 가진다면, B+트리는 리프 노드에 모든 data를 가진다.

2. 모든 리프노드가 연결 리스트의 형태를 띄고 있다.

   B트리는 옆에 있는 리프 노드를 검사할 때 다시 루트 노드부터 검사해야한다면, B+트리는 리프노드에서 선형검사를 수행할 수 있어 시간 복잡도가 굉장히 줄어듭니다.

3. 리프 노드의 부모 key는 리프 노드의 첫번째 key보다 작거나 같다.

### M차 B+트리의 특징

* 노드는 최대 M개부터 M/2개까지의 자식을 가질 수 있다.

* 노드에는 최대 M-1개부터 (M/2)-1개의 키가 포함될 수 있다.

* 노드의 키가 x개라면 자식의 수는 x+1개이다.

* 최소 차수는 자식 수의 하한값을 의미하며, 최소 차수가 t라면 M=2t-1 을 만족한다.

  (최소 차수가 2라면, 3차 B+트리이고, key의 하한은 1개이다.)

### key 검색 과정

B-Tree와 동일하다.

### key 삽입 과정

* **Case 1) 분할이 일어나지 않고, 삽입 위치가 리프 노드의 가장 앞 key자리가 아닌 경우**

  B-Tree와 똑같이 수행한다.

* **Case 2) 분할이 일어나지 않고, 삽입 위치가 리프노드의 가장 앞 key자리인 경우**

  삽입 후 부모 key를 삽입된 key로 갱신하고 data를 넣어준다.

* **Case 3) 분할이 일어나는 삽입 과정**

  * 분할이 일어나는 노드가 리프노드가 아니라면,

    기존 B-Tree와 똑같이 분할을 진행한다.

    중간 key를 부모 key로 올리고, 분할한 두 개의 노드를 왼쪽, 오른쪽 자식으로 설정한다.

  * 분할이 일어나는 노드가 리프노드라면,

    중간 key를 부모 key로 올리지만, 오른쪽 노드에 중간 key를 포함하여 분할한다.

    **또한 리프노드는 연결리스트이기 때문에 왼쪽 자식 노드와 오른쪽 자식 노드를 이어줘 연결리스트 형태를 유지한다.** (=> B-Tree의 분할과 다른점)

### key 삭제 과정

B-Tree와 유사하지만, 삭제할 key는 무조건 리프노드에 존재하는 점, k를 삭제하기위해 검색하는 과정에서 index에 존재할 수 있다는 점이 다르다.

* **Case 1) 삭제할 key k가 index에 없고, 리프노드의 가장 처음 key가 아닌 경우**

  기존 B-Tree와 동일하다. 그냥 삭제.

* **Case 2) 삭제할 key k가 리프노드의 가장 처음 key인 경우**

  항상 k가 index 내에 존재한다.

  1. 먼저 리프 노드의 k를 삭제하는 과정을 수행한다. 
     * key의 개수가 최소 key의 개수라면, B-Tree의 삭제 과정 중 형제 노드의 key를 빌려오는 경우나 부모 key와 병합하는 등 과정은 동일하게 수행한다. 단, 리프 노드가 병합할 때는 부모 key와 오른족 자식의 처음 key가 동일하기 때문에 부모 key를 가져오는 과정만 생략하고 왼쪽 자식과 오른쪽 자식만 병합한다.
  2. 리프노드의 k를 삭제한 후, index내의 k를 inorder successor로 변경한다.

### B+Tree의 장단점

**장점**

* 블럭사이즈(노드 사이즈)를 더 많이 이용할 수 있다. (key값에 대한 HardDist Access주소가 없기 때문)
* Leaf Node끼리 LinkedList로 연결되어 있어 연속적인 탐색에 매우 유리하다.

**단점**

* B-Tree의 경우 Best Case에는 루트에서 끝날 수 있지만, B+Tree의 경우 무조건 Left 노드까지 가야한다.

</br>

## B-Tree와 B+Tree의 공통점, 차이점

**공통점**

1. 모든 leaf의 depth가 같다.
2. 각 node에는 k/2~k개의 item이 들어있어야 한다.
3. search가 비슷하다.
4. add시, overflow가 발생하면 split한다.
5. delete시, underflow가 발생하면 redistribution하거나 merge한다.

**차이점**

1. B-tree의 각 노드에서는 key뿐만 아니라 data도 들어갈 수 있다.

   (여기서 data는 dist block으로의 포인터가 될 수 있다.)

   B+tree는 각 node에서는 key만 들어가야 한다. B+tree에서 data는 오직 leaf에만 존재한다.

2. B+tree는 B-tree와는 달리 add, delete가 leaf에서만 이루어진다.

3. B+tree는 leaf node끼리 linked list로 연결되어 있다.
