# 정렬 알고리즘

## 정렬 종류
1. [선택 정렬](#)
2. [버블 정렬](#)
3. [삽입 정렬](#)
4. [퀵 정렬](#)
5. [병합 정렬](#)
6. [힙 정렬](#)
7. [기수 정렬](#)
8. [계수 정렬](#)



![image](https://user-images.githubusercontent.com/33089715/116872970-dae98e80-ac51-11eb-8c6a-00c19615d1e3.png)

> in-place 하다는 것은 구현할 때 추가적인 메모리가 필요 없다는 의미이다.

> unstable 하다는 것은 동일한 숫자가 있을 경우 sort 후에 위치가 바뀔 가능성이 있다는 의미이다.
## 선택 정렬(Selection Sort)
가장 작은 것을 선택하여, 계속해서 앞으로 보내주는 방법(원래 앞에 있던 숫자와 자리를 바꿔준다.)

해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘이다.


### 특징
+ 구현이 쉽다.
+ in-place 하다.
+ unstable 하다.
    + ex) 5a 4 5b 2 7
    + → 처음 2를 선택하게 되면 5a와 2의 위치가 바뀐다.
    + → 2 4 5b 5a 7

### 시간 복잡도
O(N^2)
+ 최선, 평균, 최악 모두 동일하다.
+ 10개의 요소를 선택 정렬을 통해 정렬할 때는, 10번+9번+8번+7번+...+1번의 연산이 필요하다.
+ N개 요소를 선택정렬 할 때 필요한 수행 시간은 N*(N-1)/2 이다.

### 과정
1. 주어진 배열 중에 최소값을 찾는다.
2. 그 값을 맨 앞에 위치한 값과 교체한다. (pass)
3. 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체한다.

### 구현
```python
for i in range(len(a)-1): # 리스트의 크기-1만큼 반복
    for j in range(i+1, len(a)): # 해당 인덱스+1부터, 리스트 크기만큼 반복
        if a[i] > a[j]: # 인덱스의 값이 비교 인덱스보다 더 크다면
            a[i] , a[j]  = a[j], a[i] # swap 해주기
```

## 버블 정렬(Bubble Sort)
바로 이웃한 두 수를 비교하여, 작은 값을 앞으로 보내는 방법
### 특징
+ 가장 효율성이 떨어지는 알고리즘
+ in-place 하다.
+ stable 하다.

### 시간 복잡도
O(N^2)
+ 매번 2개의 원소를 비교하기 때문에 최선, 평균, 최악 모두 시간복잡도가 동일하다.
+ 한 번 반복할 때마다, 비교하는 요소가 하나씩 줄어든다.
+ 10개의 요소를 버블 정렬을 통해 정렬할 때는, 10번+9번+8번+7번+...+1번의 연산이 필요하다.
    [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] → [9, 8, 7, 6, 5, 4, 3, 2, 1, 10] → [8, 7, 6, 5, 4, 3, 2, 1, 9, 10]...
+ 선택 정렬과 시간 복잡도가 동일하지만 실제 수행 시간은 선택 정렬보다 더 느리다. 
    + 이유? 선택 정렬은 반복마다 한 번의 swap 과정만 거치지만, 버블 정렬은 한 번 반복 마다 계속해서 옆자리 수와 크기를 비교하여 swap 과정을 훨씬 많이 거친다.

### 과정
1. 1회전에 첫 번째 원소와 두 번째 원소를, 두 번째 원소와 세 번째 원소를, 세 번째 원소와 네 번째 원소를, … 이런 식으로 (마지막-1)번째 원소와 마지막 원소를 비교하여 조건에 맞지 않는다면 서로 교환한다.
1. 1회전을 수행하고 나면 가장 큰 원소가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 원소는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 원소까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.

### 구현
```python
for i in range(1, len(a)): # 리스트의 크기만큼 반복
    for j in range(0, len(a)-1): # 각 회전당 정렬이 끝나지 않은 친구들을 위해 반복
        if a[j] > a[j+1]: # 현재 인덱스의 값이 다음 인덱스의 값보다 크면 실행
           a[j+1], a[j] = a[j], a[j+1] # swap해서 위치 바꾸기
```

## 삽입 정렬(Insertion Sort)
첫번 째 숫자부터 시작해서 각 숫자를 적절한 위치에 삽입하는 방법(두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬)

각 숫자를 삽입할 위치를 살펴볼 때, 그 숫자의 앞의 숫자들은 이미 정렬된 상태
### 특징
+ in-place 하다.
+ stable 하다.
+ 필요한 만큼 이동하기 때문에 선택정렬과 버블정렬에 비해 빠르다
    + Selection Sort는 k+1번째 요소를 찾기 위해 나머지 모든 요소들을 탐색하지만 Insertion Sort는 k+1번째 요소를 배치하는 데 필요한 만큼의 요소만 탐색하기 때문에 훨씬 효율적으로 실행된다는 차이가 있다.

> faster 삽입정렬 > 선택정렬 > 버블정렬 slower

### 시간 복잡도
O(N^2)
+ 실제 연산 속도는 셋 중에서 가장 빠르다.
+ 최선의 경우에 O(N)이라는 엄청난 효율성을 가지기 때문에, 정렬된 상태에서 삽입 정렬을 하면 매우 효율적이다.

### 과정
1. 정렬은 2번째 위치(index)의 값을 temp에 저장한다.
2. temp와 이전에 있는 원소들과 비교하며 삽입해나간다.
3. '1'번으로 돌아가 다음 위치(index)의 값을 temp에 저장하고, 반복한다.

### 구현
```python
for i in range(1, len(a)): # 리스트의 크기만큼 반복
    for j in range(i, 0, -1): # j 인덱스의 값이 줄어드면서 삽입할 위치를 찾을 때까지 반복
        if a[j] < a[j-1]: # 현재 인덱스가 앞의 원소보다 작다면
            a[j], a[j-1] = a[j-1], a[j] # swap해서 값 뒤로 밀어내기
        else : break # 불필요한 반복을 피하기 위해 break
```
## 퀵 정렬(Quick Sort)
정렬해야 하는 요소를 분할시켜서 정렬하는 방법. 특정한 값(**pivot**)을 기준으로, 큰 수와 작은 수를 반으로 나눠(두 집합으로) 정렬하는 방법이다.

### 특징
+ divide-and-conquer
+ 일반적으로 가장 빠른 정렬이다.
+ in-place 하다.
+ unstable 하다

> [분할 정복(divide and conquer) 방법]
>> 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 문제를 해결하는 전략
### 시간 복잡도
O(NlogN)
+ logN : 순환 호출의 깊이(반 씩 나눠 비교함)
+ N : 각 순환 호출에서는 전체 리스트의 대부분이 레코드를 비교해야 하므로 평균 n번의 비교가 이루어 진다.
![image](https://user-images.githubusercontent.com/33089715/116875684-49c8e680-ac56-11eb-95b3-5abe1232a91c.png)

최악의 경우 : O(N^2)
+ 이미 오름차순 혹은 내림차순 정렬이 된 경우 pivot 값 설정(제일 왼쪽 or 제일 오른 쪽을 선택했을 경우)에 따라 최악의 경우를 만날 수 있다.
+ n : 순환 호출의 깊이
+ n : 각 순환 호출 단계의 비교 연산
![image](https://user-images.githubusercontent.com/33089715/116875796-73820d80-ac56-11eb-8085-244aaea6142c.png)


### 과정
1. 배열 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.
2. 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 배열을 둘로 나눈다. 이렇게 배열을 둘로 나누는 것을 분할(Divide) 이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.
3. 분할된 두 개의 작은 배열에 대해 재귀(Recursion)적으로 이 과정을 반복한다.
4. 재귀 호출이 한번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.
![Untitled](https://user-images.githubusercontent.com/33089715/116875983-bd6af380-ac56-11eb-8935-4b6965420531.png)

### 구현
```python
def quickSort(a, start, end):# 재귀함수용 함수 선언(리스트, 시작인덱스, 종료인덱스)
    # print(a)
    if start < end: # 시작 인덱스 보다 끝 인덱스가 클 경우
        left = start # left 변수에 시작 인덱스 할당
        pivot = a[end] #  //pivot 값은 a리스트에 마지막 원소 값
        for i in range(start, end): # 시작인덱스부터 끝 원소까지 반복
            if a[i] < pivot: # 리스트 인덱스 값이 pivot 값보다 작을 경우라면
                a[i], a[left] = a[left], a[i] #  해당 인덱스와 left인덱스  swap
                left += 1 # 인덱스 하나 증가 시켜주기(자리를 옮겨가며 비교해야 하기 때문에)
        a[left] , a[end] = a[end], a[left] # left인덱스와 끝 인덱스 swap
        print(left)
        quickSort(a, start, left-1) # 재귀 호출 (리스트, 시작 인덱스, left-1)
        quickSort(a, left+1, end) # 재귀 호출 (리스트, left+1, 종료인덱스)
quickSort(a, 0, len(a)-1)
```

## 병합 정렬(Merge Sort)
분할 정복 방법을 사용하는 정렬(**Divid and Conquer**)로, 정확하게 반 씩 나누면서 정렬

### 특징
+ divide-and-conquer
+ in-place 하다.
+ stable 하다
+ 퀵소트와의 차이점
    + 퀵정렬 : 우선 피벗을 통해 정렬(partition) → 영역을 쪼갬(quickSort)
    + 합병정렬 : 영역을 쪼갤 수 있을 만큼 쪼갬(mergeSort) → 정렬(merge)

> [분할 정복(divide and conquer) 방법]
>> 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 문제를 해결하는 전략
### 시간 복잡도
O(NlogN)
- 무조건 반으로 나누기 때문에 퀵 정렬보다는 느리지만, 퀵 정렬과 달리 최악의 경우도 NlogN을 보장해준다.
- 정렬해야 할 데이터가 N개이면, 이 데이터의 배열을 다시 합치면서 정렬하는 과정은 로그의 밑이 2인 logN 이다.
- 기존 데이터를 담을 추가 공간이 필요하므로 메모리 활용이 비효율적이다.

![image](https://user-images.githubusercontent.com/33089715/116875796-73820d80-ac56-11eb-8085-244aaea6142c.png)


### 과정
1. 모든 요소가 자기 자신만 남을 때 까지 반으로 나눈다.
2. 그 다음 인접한 두 수끼리 합친다.(각각 숫자 2개씩) 합치면서 두 수를 비교하여 정렬
3. 그 후 인접한 두 집합(각각 2개씩 가진 집합, 총 4개의 수를 가지게 됨)를 합치면서 정렬


### 구현
```python
def mergeSort(a):
    if len(a) > 1: # 배열의 길이가 1보다 클 경우 재귀함수 호출 반복
        mid = len(a)//2 # 2로 나눈 몫 (중간 값) 취함
        la, ra = a[:mid], a[mid:] # la 중간 값을 기준으로 왼쪽, ra 중간 값을 기준으로 오른쪽
        mergeSort(la) # 왼쪽 서브 리스트의 값을 기준으로 병합정렬 재귀 호출
        mergeSort(ra) # 오른쪽 서브 리스트의 값을 기준으로 병합정렬 재귀 호출
        li, ri, i = 0, 0, 0 # 정렬을 위한 변수 선언 (왼쪽, 오른쪽, 기준)
        while li < len(la) and ri < len(ra): # 서브 리스트의 정렬이 끝날 때까지 반복
            if la[li] < ra[ri]: # 오른쪽 리스트의 값이 클 경우라면
                a[i] = la[li] # 왼쪽 리스트의 해당 인덱스의 값을 할당
                li += 1 # 왼쪽 리스트의 인덱스 하나 증가
            else: # 왼쪽 리스트의 값이 클 경우라면
                a[i] = ra[ri] # 오른쪽 리스트의 해당 인덱스의 값을 할당
                ri += 1 # 오른쪽 리스트의 인덱스 하나 증가
            i += 1 # 기준 인덱스 증가
        a[i:] = la[li:] if li != len(la) else ra[ri:]
      # 왼쪽 리스트의 인덱스의 값이 서브 리스트의 값과 같지 않을 경우라면(정렬 끝),
      # 왼쪽 서브 리스트의 값을 리스트에 덮어쓰기, 그렇지 않은 경우라면 오른쪽 서브 리스트의 값 할당                                   
mergeSort(a)
```
## 힙 정렬(Heap Sort)
완전 이진 트리를 기본으로 하는 힙(Heap) 자료구조를 기반으로한 정렬 방식

### 특징
+ 완전 이진 트리의 일종
+ unstable 이다.
+ 반 정렬 상태(완전 정렬된 상태가 아님)이며, 완전 이진트리와는 다르게 중복 값이 허용된다.
+ 삽입/삭제는 트리 구조이기 때문에 O(logN)으로 매우 빠르다.
+ 보통 우선순위 큐가 힙으로 많이 구현되는데, 배열과 리스트보다 효율적이다.

+ 힙소트를 사용하는 경우
    + 가장 크거나 가장 작은 값을 구할 때(최소힙 or 최대힙의 루트 값이기 때문에 한번의 힙 구성을 통해 구하는 것이 가능)
    + 최대 k 만큼 떨어진 요소들을 정렬할 때(삽입 정렬보다 더욱 개선된 결과를 얻어낼 수 있음)

> [완전 이진 트리]
>> 삽입할 때 왼쪽부터 차례대로 추가하는 이진 트리
### 시간 복잡도
O(NlogN) 
+ 힙 트리 높이가 거의 logN 이므로 하나의 요소를 힙에 삽입하거나 삭제할 때 힙을 재정비하는 시간이 logN 소요
+ 요소의 개수가 N

### 과정
1. 최대 힙을 구성(내림차순 sort 경우)
2. 현재 힙 루트는 가장 큰 값이 존재함. 루트의 값을 마지막 요소와 바꾼 후, 힙의 사이즈 하나 줄임
3. 힙의 사이즈가 1보다 크면 위 과정 반복

![image](https://user-images.githubusercontent.com/33089715/116876886-22731900-ac58-11eb-883d-82da25eefdc4.png)
![image](https://user-images.githubusercontent.com/33089715/116876891-2606a000-ac58-11eb-8808-d217ebbbbdf8.png)



### 구현
```cpp
public void heapSort(int[] array) {
    int n = array.length;
    
    // max heap 초기화
    for (int i = n/2-1; i>=0; i--){
        heapify(array, n, i); // 일반 배열을 힙으로 구성
    }
    
    // extract 연산
    for (int i = n-1; i>0; i--) {
        swap(array, 0, i); 
        heapify(array, i, 0); // 요소가 하나 제거된 이후에 다시 최대힙을 구성
    }
}
public void heapify(int array[], int n, int i) {
    int p = i;
    int l = i*2 + 1;
    int r = i*2 + 2;
    
    //왼쪽 자식노드
    if (l < n && array[p] < array[l]) {
        p = l;
    }
    //오른쪽 자식노드
    if (r < n && array[p] < array[r]) {
        p = r;
    }
    
    //부모노드 < 자식노드
    if(i != p) {
        swap(array, p, i);
        heapify(array, n, p);
        //다시 최대 힙을 구성할 때까지 부모 노드와 자식 노드를 swap하며 재귀 진행
    }
}
```
## 기수 정렬(Radix Sort)
## 계수 정렬(Counting Sort)
---
### 출처
시간 복잡도 사진 : https://program-developer.tistory.com/106

구현 코드 : https://hsp1116.tistory.com/33

https://gyoogle.dev/blog/algorithm/Counting%20Sort.html