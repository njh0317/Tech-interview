# Java

[JVM](#jvm)

1. [JVM의 기능은?](#jvm의-기능은)
2. [자바 컴파일 과정을 설명해보세요.](#자바-컴파일-과정을-설명해보세요)
3. [JVM 메모리 영역을 설명해보세요.](#jvm-메모리-영역을-설명해보세요)

[Garbage Collection](#garbage-collection)

1. [Garbage Collection이란?](#garbage-collection이란)
2. [Garbage Collection의 동작 방식은?](#garbage-collection의-동작-방식은)
3. [Minor GC가 무엇이고, 어떻게 동작하는지?](#minor-gc가-무엇이고-어떻게-동작하는지)
4. [Major GC가 무엇이고, 어떻게 동작하는지?](#major-gc가-무엇이고-어떻게-동작하는지)

[Java Programming](#java-programming)

1. [Java의 장단점?](#java의-장단점)
2. [접근 제어자의 종류와 특징?](#접근-제어자의-종류와-특징)
3. [데이터 타입(primitive, reference)의 종류와 특징?](#데이터-타입primitive-reference의-종류와-특징)
4. [Wrapper Class란?](#wrapper-class)
5. [Boxing, UnBoxing?](#boxing-unboxing)
6. [non-static멤버와 static멤버의 차이?](#non-static멤버와-static멤버의-차이)
7. [Java의 main메소드가 static인 이유?](#java의-main메소드가-static인-이유)
8. [final 키워드의 역할?](#final-키워드의-역할)
9. [Java의 Generic이란?](#java의-generic이란)
10. [클래스, 객체, 인스턴스 차이?](#클래스-객체-인스턴스-차이)
11. [Overriding, Overloading?](#overriding-overloading)
12. [동적 바인딩, 정적 바인딩?](#동적-바인딩-정적-바인딩)
13. [java는 Call by Reference? Call by Value?](#java는-call-by-reference-call-by-value)
14. [인터페이스와 추상 클래스의 차이점?](#인터페이스와-추상-클래스의-차이점)
15. [Collection의 특징과 사용하는 이유?](#collection의-특징과-사용하는-이유)
16. [Annotation이란?](#annotation이란)
17. [String vs StringBuilder vs StringBuffer?](#string-vs-stringbuilder-vs-stringbuffer)
18. [동기화? 비동기화?](#동기화-비동기화)
19. [==와 equals()의 차이?](#와-equals의-차이)
20. [Java Reflection(리플렉션)?](#java-reflection리플렉션)
21. [생성자?](#생성자)
22. [this vs super](#this-vs-super)

[Object-Oriented Programming](#object-oriented-programming)

1. [OOP의 4가지 특징?](#oop의-4가지-특징)
2. [OOP의 5대 (설계)원칙?](#oop의-5대-설계원칙)
3. [절차 지향 vs 객체 지향 vs  함수형?](#절차-지향-vs-객체-지향-vs-함수형)

[기타](#기타)

## JVM

### JVM의 기능은?
JVM은 Java Virtual Machine, 자바 가상 머신으로, Stack기반의 가상머신입니다. 

주요 기능으로는 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것입니다. 또, 자바 프로그램이 어느 기기나 운영체제 상에서도 독립적으로 실행될 수 있도록 하고, 프로그램 메모리를 관리하고 최적화합니다.

</br>

### 자바 컴파일 과정을 설명해보세요.
1. 자바 소스코드(.java)를 자바 컴파일러가 읽어들여 자바 바이트 코드(.class)로 변환시킵니다.
2. 컴파일된 바이트 코드를 JVM 클래스 로더(Class Loader)에게 전달합니다.
3. 클래스 로더는 동적 로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data Area), 즉 JVM의 메모리에 올립니다.
4. 실행 엔진(Excution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행합니다. 이 때 실행 엔진은 두 가지 방식으로 변경합니다.

    1. 인터프리터 : 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행합니다. 전체적인 실행 속도가 느리다는 단점이 있습니다. 중복되는 바이트 코드들에 대해서도 매번 컴파일을 하게 되면 비효율적이며 Running Time도 길어지게 됩니다. 이렇게 중복되는 바이트 코드에 대해서는 JIT 컴파일러를 사용합니다.
    2. JIT 컴파일러(Just in time compiler) : 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이 후에는 해당 메서드를 더이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식입니다. 전체적인 실행 속도는 인터프리팅 방식보다 빠릅니다.  

</br>

### JVM 메모리 영역을 설명해보세요.
Runtime Data Area로 프로그램을 수행하기 위해 OS에서 할당받은 메모리입니다. PC Register, JVM Stack영역, Native Method Stack, Method Area, Heap영역으로 구성되어 있습니다.

<img src="https://user-images.githubusercontent.com/33208360/116801888-10568500-ab49-11eb-9497-979053d8e60c.png" alt="image" style="zoom: 50%;" />

먼저, **PC Register**는 Thread가 생성될 때마다 생성되는 공간으로, Thread마다 하나씩 존재합니다. thread가 어떤 부분의 명령을 실행해야할 지에 대한 기록을 하는 부분으로 현재 수행 중인 JVM명령의 주소를 갖습니다.

두 번째로, **JVM Stack**영역은 프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역입니다. 각종 형태의 변수나 임시 데이터, 스레드나 메소드의 정보를 저장합니다.

(:heavy_plus_sign: 특징: 메소드를 호출할 때마다 그 메소드만을 위한 공간으로 각각의 Stack 프레임이 생성됩니다. 메소드 수행이 끝나면 프레임별로 삭제됩니다.

또, 호출된 메소드의 매개변수, 메소드 안에서 사용되는 값인 지역변수, 리턴 값 및 연산시 일어나는 값 등을 임시로 저장합니다. ) 

세 번째로, **Native Method Stack**은 자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역입니다. Java가 아닌 다른 언어로 작성된 코드를 위한 공간으로, 일반 프로그램처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역입니다.

네 번째로, **Method Area**(=Class Area = Stack Area)는 클래스 정보를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간입니다.

마지막으로, **Heap**영역은 객체를 저장하는 가상 메모리 공간으로, `new` 연산자로 생성된 객체와 배열을 저장합니다. (Class Area영역에 올라온 클래스들만 객체로 생성할 수 있다.)

Heap은 세 부분으로 나뉘는데, Permanent 영역, New/Young영역, Old영역으로 나뉩니다.

1. Permanent 영역은 생성된 객체 정보의 주소값이 저장되는 공간입니다. Class Loader에 의해 로드되는 class, Method 등에 대한 메타정보가 저장되는 영역이고, JVM에 의해 사용됩니다. (+ 또, Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에 사용됩니다. 내부적으로 Reflection기능을 자주 사용하는 Spring프레임워크를 이용할 경우 이 영역에 대한 고려가 필요.)
2. New/Young 영역은 Eden과 Survivor 0/1공간이 있는데, Eden은 객체들이 최초로 생성되는 공간이며, Survivor0/1 은 Eden에서 참조되는 객체들이 저장되는 공간입니다.
3. Old영역은 New Area에서 일정 시간 참조되고 있는, 살아남은 객체들이 저장되는 공간입니다.

(:heavy_plus_sign: 인스턴스는 소멸 방법과 소멸 시점이 지역변수와 다르기 때문에 Heap이라는 별도의 영역에 할당됩니다. )

**:heavy_plus_sign: Java의 Heap 영역**

Heap 영역은 처음 설계될 때 다음 2가지를 전제로 설계되었습니다.(Weak Generational Hypothesis)

1. 대부분의 객체는 금방 접근 불가능한 상태(Unreachable)가 된다.
2. 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.

즉, 객체는 대부분 일회성이며, 메모리에 오랫동안 남아있는 경우가 드물다는 것을 의미합니다. 그렇기 때문에 객체의 생존기간에 따라 물리적인 Heap 영역을 나누게 되었는데, 이에 따라 Young, Old 총 2가지 영역으로 설계되었습니다.

**1) Young 영역**

새롭게 생성된 객체가 할당(Allocation)되는 영역으로, 대부분의 객체가 금방 Unreachable 상태가 되기 때문에, 많은 객체가 Young영역에 생성되었다가 사라집니다. 이 Young 영역에 대한 Garbage Collection을 **Minor GC**라고 부릅니다. 

**2) Old 영역**

Young 영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역으로, 복사되는 과정에서 대부분 Young 영역보다 크게 할당되고 크기가 큰 만큼 Garbage는 적게 발생합니다. 이 Old 영역에 대한 Garbage Collection을 **Major GC** (Full GC)라고 부릅니다. 

**+) Old 영역에 있는 객체가 Young 영역의 객체를 참조하는 경우**

이 경우를 대비해 Old 영역에는 512바이트의 덩어리로 되어있는 카드 테이블이 존재합니다. 카드 테이블에는 Old영역에 있는 객체가 Young 영역의 객체를 참조할 때마다 그에 대한 정보가 표시됩니다. Young 영역에서 Minor GC가 실행될 때, 모든 Old 영역에 존재하는 객체를 검사하여 참조되지 않는 Young영역의 객체를 식별하는 것은 비효율적이기 때문입니다. 그렇기 때문에 Minor GC가 진행될 때, 카드 테이블만 조회하여 GC의 대상인지 식별할 수 있도록 하고 있습니다. 

</br>

## Garbage Collection

### Garbage Collection이란?

프로그램을 개발하다보면 유효하지 않은 메모리가 발생하게 되는데, JVM의 Garbage Collector가 불필요한 메모리를 알아서 정리해주는 과정을 말합니다. 그래서 Java를 이용해 개발하면 개발자가 메모리를 직접 해제하지 않아도 되기 때문에 개발효율을 높일 수 있습니다. 

Heap영역의 Young영역에서 일어나는 Minor GC와 Old영역에서 일어나는 Major GC가 있습니다.

(:heavy_plus_sign: Java나 Kotlin에서는 메모리 누수를 방지하기 위해 Garbage Collector가 주기적으로 검사하여 메모리를 청소해줍니다.)

(:heavy_plus_sign: Java에서 `System.gc()`를 이용해 호출할 수 있지만, 해당 메소드를 호출하는 것은 시스템의 성능에 매우 큰 영향을 미치므로 절대 호출해서는 안됨. )

</br>

### Garbage Collection의 동작 방식은?

기본적으로 'Stop the World', 'Mark and Sweep' 2가지의 공통적인 단계를 따릅니다.

먼저, **Stop The World**는 GC를 실행하기 위해 JVM이 애플리케이션의 실행을 멈추는 작업입니다. GC가 실행될 때는 GC를 실행하는 thread를 제외한 모든 thread들의 작업이 중단되고, GC가 완료되면 작업이 재개됩니다. 

다음으로, **Mark and Sweep**과정으로, GC는 Stack의 모든 변수 또는 Reachable 객체를 스캔하면서 각각이 어떤 객체를 참조하고 있는지를 탐색합니다. 그리고 사용되고 있는 메모리를 식별하는데 이러한 과정을 Mark라고 합니다. 이후에 Mark되지 않은 객체들을 메모리에서 제거하는데, 이러한 과정을 Sweep이라고 합니다.

</br>

### Minor GC가 무엇이고, 어떻게 동작하는지?

Heap의 Young 영역에 대한 Garbage Collection으로, Young영역은 1개의 Eden영역과 2개의 Survivor영역으로 총 3가지로 나뉘어지는데, Eden영역은 새로 생성된 객체가 할당되는 영역이고, Survivor은 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역입니다.

Minor 동작 방식은 

1. 먼저 새로 생성된 객체가 Eden 영역에 할당됩니다.

2. 객체가 계속 생성되어 Eden영역이 꽉 차게 되고, Minor GC가 실행됩니다.

   Eden영역에서 사용되지 않는 객체의 메모리는 해제되고, Eden영역에서 살아남은 객체는 1개의 Survivor영역으로 이동됩니다.

3. 1~2번의 과정이 반복되다가, Survivor 영역이 가득 차게 되면 Survivor영역의 살아남은 객체를 다른 Survivor영역으로 이동시킵니다.

4. 이러한 과정을 반복하여 계속 살아남은 객체는 Old 영역으로 이동(Promotion)됩니다.

이때, 객체의 생존 횟수를 카운트하기 위해 Minor GC에서 살아남은 횟수를 의미하는 **Age**를 Object Header에 기록합니다. 그리고 기록된 **Age**를 보고 Promotion여부를 결정합니다.

(:heavy_plus_sign: Survivor 영역 중 1개는 반드시 사용되어야 합니다. 두 영역 모두 데이터가 존재하거나, 두 영역의 사용량이 모두 0이라면 현재 시스템이 정상적인 상황이 아님을 파악할 수 있습니다. )

</br>

### Major GC가 무엇이고, 어떻게 동작하는지?

Heap의 Old 영역에 대한 Garbage Collection입니다. Young영역에서 오래 살아남은 객체가 Old 영역으로 Promotion되는데, 객체들이 계속해서 Promotion되어 Old영역의 메모리가 부족해지면 Major GC가 발생하게 됩니다.

(:heavy_plus_sign: Young영역은 일반적으로 Old영역보다 크기가 작기 때문에 GC가 빠르게 진행됩니다. 그렇기 때문에 Minor GC는 애플리케이션에 크게 영향을 주지않습니다. 하지만 Old영역은 Young영역보다 크며, Young영역을 참조할 수도 있기 때문에 Major GC는 일반적으로 비교적 시간이 오래 걸립니다.)

</br>

## Java Programming

### Java의 장단점?

먼저 장점으로는

1. 운영체제에 독립적입니다.

   JVM에서 동작하기 때문에 특정 운영체제에 종속되지 않습니다.

2. 객체 지향 언어입니다.

   객체 지향적으로 프로그래밍하기 위해 여러 언어적 지원을 하고 있습니다. (캡슐화, 상속, 추상화, 다형성 등)

3. 자동으로 메모리 관리를 해줍니다.

   JVM에서 Garbage Collector라는 데몬 스레드에 의해 Garbage Collection이 일어납니다. GC로 인해 별도의 메모리 관리가 필요 없으며, 비즈니스 로직에 집중할 수 있습니다.

4. 멀티 스레드를 쉽게 구현할 수 있습니다.

   Java는 스레드 생성 및 제어와 관련된 라이브러리 API를 제공하고 있기 때문에 실행되는 운영체제에 상관없이 멀티 스레드를 쉽게 구현할 수 있습니다.

5. 동적 로딩(Dynamic Loading)을 지원합니다.

   애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에 클래스를 동적 로딩해서 생성합니다. 또한, 유지 보수시 해당 클래스만 수정하면 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요가 없어 유지 보수가 쉽고 빠릅니다.

그리고 단점으로는

1. 비교적 속도가 느립니다.

   Java는 한 번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고, JVM에 의해 기계어로 번역되고 실행하는 과정을 거치기 때문에 C나 C++의 컴파일 단계에서 만들어지는 완전한 기계어보다는 속도가 느립니다.

   (:heavy_plus_sign: 하지만 하드웨어의 성능향상과 바이트 코드를 기게어로 변환해주는 JIT 컴파일러 등의 기술 적용으로 JVM의 기능이 향상되어 속도의 격차가 많이 줄어들었음. )

2. 예외 처리가 불편합니다.

   프로그래머 검사가 필요한 예외가 등장한다면, 무조건 프로그래머가 선언해주어야 합니다.

</br>

### 접근 제어자의 종류와 특징?

접근 제어자는 멤버 또는 클래스에 사용되어 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 합니다.

총 4가지로, 먼저 `public`(+)은 어떤 클래스에서라도 접근 가능한 것을 의미합니다.

`protected`(#)는 클래스가 정의되어 있는 해당 패키지 내, 그리고 해당 클래스를 상속받은 외부 패키지의 클래스에서 접근이 가능한 것을 의미합니다.

` (default)`는 클래스가 정의되어 있는 해당 패키지 내에서만 접근이 가능하도록 접근 범위를 제한하는 것을 의미합니다.

`private`(-)은 정의된 해당 클래스에서만 접근이 가능하도록 접근 범위를 제한하는 것을 의미합니다.

접근 제어자가 사용될 수 있는 곳은 클래스, 멤버 변수, 메서드, 생성자가 있습니다.

접근 제어자는 클래스의 내부에 선언된 데이터를 보호하기 위해서 사용됩니다. 데이터가 유효한 값을 유지하도록, 외부에서 함부로 변경하지 못하도록 하기 위해서 외부로부터의 접근을 제한하는 것이 필요합니다. 이것을 객체 지향 개념에서는 캡슐화라고 합니다.

</br>

### 데이터 타입(primitive, reference)의 종류와 특징?

먼저, 기본 데이터 타입 Primitive Data Type은 `byte`, `short`, `char`, `int`, `float`, `double`, `boolean`으로, 크기가 작고 고정적이기 때문에 메모리의 Stack 영역에 저장됩니다.

참조 타입 Reference Data Type은 기본형을 제외한 모든 것으로, 참조 타입의 데이터의 크기가 가변적이고 동적이기 때문에 동적으로 관리되는 Heap 영역에 저장됩니다. `new` 키워드를 이용해 객체를 생성하여 데이터가 생성된 주소를 참조하는 타입이며, `String`과 배열은 `new` 없이 생성이 가능하지만, 기본타입이 아닌 참조타입에 속합니다.

또, 값이 저장된 곳의 주소를 저장하는 공간으로 객체의 주소를 저장합니다. (**Call-By-Value**)

더이상 참조하는 변수가 없을 때 GC에 의해 제거됩니다.

</br>

### Wrapper Class?

프로그램에 따라 Primitive type의 데이터를 객체로 취급해야하는 경우가 있는데, 이런 경우에 Wrapper class는 각각의 타입에 해당하는 데이터를 인수로 전달받아, 해당 값을 가지는 객체로 만들어 줍니다. 이러한 Wrapper class는 모두 `java.lang`패키지에 포함되어 제공됩니다. 

(:heavy_plus_sign: Java에서 제공하는 Wrapper Class

 `byte, short, int, long, float, double, char, boolean`

=> `Byte, Short, Integer, Long, Float, Double, Character, Boolean` )

:heavy_plus_sign: Wrapper class는 산술 연산을 위해 정의된 클래스가 아니므로, 객체에 저장된 값을 변경할 수 없습니다. 단지, 값을 참조하기 위해 새로운 객체를 생성하고, 생성된 객체의 값만을 참조할 수 있습니다. (=> boxing, unboxing으로 처리)

</br> 

### Boxing, UnBoxing?

Boxing이란 기본형(Primitive Type)을 참조형(Reference Type)으로 변환하는 것이고, Unboxing이란 반대로 참조형을 기본형으로 바꾸는 것입니다.

또, JDK 1.5부터 Boxing과 UnBoxing이 필요한 상황에서 자바 컴파일러가 이를 자동으로 처리해주는데 이렇게 자동화된 Boxing과 UnBoxing을 AutoBoxing과 AutoUnBoxing이라고 부릅니다.

</br>

### non-static멤버와 static멤버의 차이?

non-static 멤버(인스턴스 멤버)는 객체마다 별도로 존재합니다. 객체 생성 시에 멤버가 생성되기 때문에 객체 생성 후에 멤버 사용이 가능하며, 객체가 사라지면 멤버도 사라지게 됩니다. 또, 멤버는 객체 내에 각각의 공간을 유지하기 때문에 객체 간 공유되지 않습니다.

static 멤버(클래스 멤버)는 c/c++의 전역변수와 유사한 개념으로, 클래스당 하나가 생성되며, 객체 내부가 아닌 별도의 공간에 생성됩니다. 클래스 로딩 시, 즉 객체가 생기기 전에 이미 생성되기 때문에 객체를 생성하지 않고도 사용할 수 있으며, 객체가 사라져도 멤버는 사라지지 않습니다. 프로그램이 종료될 때 사라집니다. 또, 동일한 클래스의 모든 객체들에 의해 공유됩니다.

**:heavy_plus_sign: `static` 메소드의 제약 조건**

1. `static` 메소드는 오직 `static` 멤버만 접근 가능합니다. 

   `static` 메소드는 객체가 생성되지 않은 상황에서도 사용이 가능하므로 객체에 속한 인스턴스 메소드, 인스턴스 변수 등을 사용할 수 없습니다.

   (인스턴스 메소드는 `static`멤버를 모두 사용 가능하다)

2. `static` 메소드에서는 `this` 키워드를 사용할 수 없습니다.

   `this`는 호출 당시 실행 중인 객체를 가리키는 레퍼런스로, 객체가 생성되지 않은 상황에서도 클래스 이름을 이용하여 호출이 가능한 `static` 메소드는 `this`를 사용할 수 없습니다.

</br>

### Java의 main메소드가 static인 이유?

```java
public static void main(String[] args){ ... }
```

이는 java의 `main()` 관례로, 이와 같은 메소드가 없으면 실행되지 않습니다.

JVM은 인스턴스가 없는 클래스의 `main()`을 호출해야하기 때문에 `main`은 `static`여야합니다.

(**:heavy_plus_sign: JVM과 `static`** 

1. 코드를 실행하면 컴파일러가 `.java`코드를 `.class`(byte code)로 변환합니다.
2. 클래스 로더가 `.class`파일을 메모리 영역 Runtime Data Area에 로드합니다.
3. Runtime Data Area 중 Method Area 영역에 class variable이 저장되는데, `static` 멤버 또한 여기에 포함됩니다.
4. JVM은 Method Area에 로드된 `main()`을 실행합니다.)

</br>

### final 키워드의 역할?

변수나 메소드, 또는 클래스가 변경 불가능하도록 만드는 역할을 합니다.

Primitive 변수에 적용 시, 해당 변수의 값의 변경이 불가능합니다. 즉, 새로 할당할 수 없는 변수가 됩니다.

Reference 변수에 적용 시, 참조 변수가 Heap 내의 다른 객체를 가리키도록 변경할 수 없습니다.

메소드에 적용 시, 해당 메소드를 다른 메소드에서 오버라이딩할 수 없습니다.

클래스에 적용 시, 해당 클래스의 하위 클래스를 정의할 수 없습니다. 즉, 다른 클래스에서 상속하지 못하게 됩니다.

:heavy_plus_sign: `finally` 키워드?

`try/catch` 블록이 종료될 때, 항상 실행될 코드 블록을 선택적으로 정의하기 위해 사용합니다. `finally`블록은 예외가 발생하더라도 항상 실행됩니다(JVM이 `try`블록 중 종료되는 경우 제외).

:heavy_plus_sign: `finalize()` 메소드?

Garbage Collector가 더 이상의 참조가 존재하지 않는 객체를 메모리에서 삭제하겠다고 결정하는 순간 호출됩니다.

</br>

### Java의 Generic이란?

일반적인 코드를 작성하고, 이 코드를 다양한 타입의 객체에 대하여 재사용하는 프로그래밍 기법으로, 클래스에서 사용할 타입을 클래스 외부에서 설정하는 타입입니다.

자바에서 안정성을 맡고 있으며, 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에서 사용하는 것으로, 컴파일 과정에서 타입 체크를 해주는 기능입니다. 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여주며, 그로 인해 코드도 더 간결해진다는 장점이 있습니다. 또, API를 설계하는 데에 있어서 보다 명확한 의사 전달이 가능해집니다.

> 예) ArrayList
>
> ```java
> List<String> strList = new ArrayList<>();
> List<Object> objList = new ArrayList<>();
> ```
>
>  ArrayList의 기능은 똑같지만, 리스트에 담는 내용물은 다릅니다. 이처럼 기능은 같지만, 사용하는 타입이 다를때 Generic타입을 사용합니다. (=> ArrayList는 `ArrayList<T>`로 선언되어 있으며, 해당 객체를 생성할 때 T의 타입이 정해진다.)

:heavy_plus_sign: c++의 템플릿

하나의 클래스를 서로 다른 여러 타입에서 재사용할 수 있도록 하는 방법. Java의 Generic과 유사하지만, c++ 컴파일러는 인자로 주어진 각각의 타입에 대해 별도의 템플릿 코드를 생성한다. 그렇기 때문에 다른 타입의 객체는 정적 변수를 공유하지 않는다. 하지만, java에서 정적변수는 Generic 인자로 어떤 타입을 주었는지에 관계없이 모든 객체가 공유한다. 

</br>

### 클래스, 객체, 인스턴스 차이?

클래스는 객체를 만들기 위한 설계도 혹은 틀이며, 연관되어 있는 변수와 메소드의 집합입니다.

객체는 구현할 대상으로, 클래스의 인스턴스이며 모든 인스턴스를 대표하는 포괄적인 의미를 갖습니다.

인스턴스는 구현된 구체적인 실체로, 객체를 실체화하면 그것을 인스턴스라고 부르며, 실체화된 인스턴스는 메모리에 할당됩니다. 인스턴스는 객체에 포함된다고 볼 수 있습니다.

**:heavy_plus_sign: 클래스 vs 객체**

클래스는 설계도, 객체는 설계도로 구현된 모든 대상을 의미합니다.

**:heavy_plus_sign: 객체 vs 인스턴스**

클래스 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제로 사용될 때 인스턴스라고 부릅니다. 

(인스턴스화하여 레퍼런스를 할당한 객체를 인스턴스라고 말하지만, 이는 원본으로부터 생성되었다는 것에 의미를 부여하는 것일 뿐 엄격하게 객체와 인스턴스를 나누긴 어렵다.)

</br>

### Overriding, Overloading?

우선, overriding과 overloading 모두 같은 이름의 다른 메소드를 호출하는 것을 의미합니다.

하지만, **Overriding**은 상위 클래스 또는 인터페이스에 존재하는 메소드를 하위 클래스에서 필요에 맞게 재정의하는 것을 의미합니다. Java의 경우 오버라이딩 시에 동적 바인딩됩니다. 또, 하나의 코드로 여러 객체를 처리할 수 있다는 장점이 있기 때문에 사용합니다.

**Overloading**은 두 메소드가 같은 이름과 return값을 가지고 있으나, 인자의 수나 자료형이 다른 경우를 말합니다. 

**:heavy_plus_sign: 정리**

오버로딩은 한 클래스 내에 여러 개의 같은 이름의 메소드를 정의하는 것을 말합니다. 이렇게 메소드의 이름을 동일하게 만들어 프로그램의 가독성을 증가시킬 수 있다는 장점이 있습니다.

오버라이딩은 부모로 부터 받은 메소드의 로직을 입맛에 맞게 변경하는 것(재정의)을 말합니다. 객체지향 언어의 특징인 다형성 중 하나입니다.

</br>

### 동적 바인딩, 정적 바인딩?

**동적 바인딩(Dynamic Binding)** 은 다형성을 사용하여 메소드를 호출할 때 발생하는 현상입니다. 실행시간(Runtime) 즉, 파일을 실행하는 시점에 성격이 결정됩니다.(= Runtime 시점에 해당메소드를 구현하고 있는 실제 객체 타입을 기준으로 찾아가서 실행될 함수를 호출한다. ) 실제 참조하는 객체에 따라 메소드가 실행됩니다.

**정적 바인딩(Static Binding)** 은 컴파일(Compile)시간에 성격이 결정됩니다. 변수의 타입에 따라 메소드를 호출합니다. 

</br>

### java는 Call by Reference? Call by Value?

함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성되는데, 

Call by Value(값에 의한 호출)는 함수 호출 시, 인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달됩니다. 복사된 인자는 함수 안에서 지역적으로 사용되는 local value의 특성을 가집니다. 따라서, 함수 안에서 인자 값이 변경되어도 외부의 변수 값은 변경되지 않습니다.

Call by Reference(참조에 의한 호출)는 함수 호출 시, 인자로 전달되는 변수의 레퍼런스를 전달합니다. 따라서, 함수 안에서 인자 값이 변경되면 인자로 전달된 변수의 값도 함께 변경됩니다.

**:heavy_plus_sign: Java는 항상 Call by Value이다!**

value란 기본 자료형(primitive type)의 값 또는 객체에 대한 레퍼런스로, 기본 자료형의 경우에는 해당하는 변수의 값이 복사되어 전달되고, 참조 자료형의 경우에는 해당하는 변수가 가지는 값이 레퍼런스이므로 인자로 넘길 때 Call by Value에 의해 변수가 가지고 있는 레퍼런스가 복사되어 전달됩니다.

<br>

### 인터페이스와 추상 클래스의 차이점?

**추상 클래스**란, 일반 클래스와 별 다를것이 없지만 단지 추상 메소드를 선언하여 상속을 통해 자손 클래스에서 완성하도록 유도하는 클래스입니다. 상속을 위한 클래스이기 때문에 객체를 생성할 수 없으며, 최소 한 개의 추상 메소드를 포함하는 경우 반드시 추상 클래스로 선언해야한다는 특징이 있습니다. `abstract` 예약어를 사용해 표시하고, 선언부만 작성하는 추상메소드를 선언해 구현합니다.

**인터페이스**란, 추상 클래스처럼 다른 클래스를 작성하는데 도움을 주는 목적으로 작성합니다. 클래스와 다르게 다중 상속이 가능하고, 추상 메소드와 상수만 포함하며, 인터페이스를 상속받아서 새로운 인터페이스를 만들 수 있다는 특징이 있습니다. 

**차이점**은 우선 사용의도입니다. 추상클래스는 `Is-A`, 인터페이스는 `Has-A`를 의미하는 것으로, **추상 클래스**는 추상 메소드를 자식 클래스가 구체화하여 그 기능을 확장하는 데에 목적이 있습니다.(상속을 위한 부모 클래스) **인터페이스**는 서로 관련이 없는 클래스에서 공통적으로 사용하는 방식이 필요하지만, 기능을 각각 구현할 필요가 있는 경우에 사용합니다.(구현 객체의 같은 동작을 보장)

또, 사용시기가 다릅니다. 추상 클래스는 상속관계를 보았을 때, 같은 조상 클래스를 상속하는데 똑같은 기능이 필요한 경우 사용되고, 인터페이스는 상속관계를 보았을 때, 다른 조상 클래스를 상속하는데 같은 기능이 필요할 경우에 사용됩니다.

**공통점**으로는 인스턴스(객체)를 생성할 수 없고, 선언만 있고 구현내용은 없으며, 자식 클래스가 메소드의 구체적인 동작을 구현하도록 책임을 위임한다는 점이 있습니다.

**관련 질문**

+ 자바는 왜 다중상속이 안되는 것인가? 근데 왜 다중 인터페이스는 가능한가?
   + 다중 상속을 지원하지 않는 것은 모호성 때문이다. 다중상속을 하게 되면 부모로부터 상속받은 method가 동일할 경우 누구의 부모로부터 가져와야하는지 애매해진다. 그렇기 때문에 자바에서는 다중상속을 지원하지 않는다. 하지만 왜 인터페이스는 다중 인터페이스가 가능할까? 인터페이스는 어떠한 특정 동작을 보장하기 위해 존재하기 때문이다. 이러한 부분이 차이점이라고 할 수 있다.

</br>

### Collection의 특징과 사용하는 이유?

Collection은 인터페이스로, 주요 인터페이스로 `List`, `Set`, `Map`이 있습니다. `List`와 `Set` 인터페이스는 `Collection`인터페이스를 상속받아 공통된 부분을 `Collection`인터페이스에서 정의하고 있습니다.  `Map`의 경우 구조상의 차이로 인해 Collection 인터페이스를 상속받고 있지는 않지만, Collection으로 분류됩니다.

특징으로는

1. 우선, `Set`인터페이스는 순서를 유지하지 않는 데이터의 집합으로, 데이터의 중복을 허용하지 않습니다. 구현 클래스로는 `HashSet`, `TreeSet`이 있습니다.
   * `HashSet`은 가장 빠른 임의 접근 속도를 가지며, 순서가 없습니다.
   * `TreeSet`은 정렬방법을 지정할 수 있습니다.
2. `List` 인터페이스는 순서가 있는 데이터의 집합으로, 데이터의 중복을 허용합니다. 구현 클래스로는 `LinkedList`, `Vector`, `ArrayList`가 있습니다.
   * `LinkedList`는 양방향 포인터 구조로, 데이터의 삽입, 삭제가 빈번할 경우 데이터의 위치 정보만 수정하면 되기 때문에 유용합니다. Stack, Queue, 양방향 Queue 등을 만들기 위한 용도로 쓰입니다.
   * `Vector`는 과거에 대용량 처리를 위해 사용했으며, 내부에서 자동으로 동기화 처리가 일어나 비교적 성능이 좋지 않고 무거워 잘 쓰이지 않습니다.
   * `ArrayList`는 단방향 포인터 구조로 각 데이터에 대한 인덱스를 가지고 있어 조회 기능에 성능이 뛰어나다는 특징이 있습니다.
3. `Map` 인터페이스는 키(Key), 값(Value)의 쌍으로 이루어진 데이터의 집합으로, 순서는 유지되지 않으며, 키(Key)의 중복은 허용하지 않으나 값(Value)의 중복은 허용하는 특징이 있습니다. 구현 클래스로는 `Hashtable`, `HashMap`, `TreeMap`이 있습니다.
   * `Hashtable`은 `HashMap`보다는 느리지만 동기화를 지원하며, `null`이 불가합니다.
   * `HashMap`은 중복과 순서가 허용되지 않으며, `null`값이 가능합니다.
   * `TreeMap`은 정렬된 순서로 키(Key)와 값(Value)을 저장하여 검색이 빠르다는 특징이 있습니다.

이를 사용하는 이유는 다수의 Data를 다루는데 표준화된 클래스를 제공해주기 때문에 Data Structure을 직접 구현하지 않고 편하게 사용할 수 있기 때문입니다. 또, 배열과 다르게 객체를 보관하기 위한 공간을 미리 정하지 않아도 되므로, 상황에 따라 객체의 수를 동적으로 정할 수 있기 때문에 프로그램의 공간적인 효율성을 또한 높여준다는 장점이 있습니다.

</br>

### Annotation이란?

본래 주석이라는 뜻으로, 인터페이스를 기반으로 한 문법을 말합니다. 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있고, 해석되는 시점을 정할 수도 있습니다.

종류는 총 3가지로 `@Override`와 같이 JDK에 내장되어있는 `built-in`어노테이션, 어노테이션에 대한 정보를 나타내기 위한 `Meta`어노테이션, 그리고 개발자가 직접 만들어낸 `custom`어노테이션이 있습니다.

</br>

### String vs StringBuilder vs StringBuffer?

1. 우선 **String**은 새로운 값을 할당할 때마다 새로운 객체가 생성됩니다. 즉, `String`에 저장된 문자열은 바꿀 수 없습니다. (불변성을 가진다. -> `private final char[]`형태) 

   (생성된 `String` 객체들은 Heap에 쌓이게 되므로 `String + String + ...`와 같은 연산은 메모리 관리에 치명적입니다. 따라서, `String`을 직접 더하는 것보다 `StringBuilder`나 `StringBuffer`를 사용하는 것이 효율적입니다.)

StringBuilder와 StringBuffer는 메모리에 `append()`하는 방식으로, 클래스에 대한 객체를 직접 생성하지 않습니다. (가변성을 가진다.)

2. **StringBuilder**는 변경가능한 문자열이며, 비동기로 처리합니다. 그렇기 때문에 단일 스레드 환경에서 `StringBuffer`보다 비교적 성능이 뛰어나다는 특징이 있습니다.
3. **StringBuffer**는 변경가능한 문자열이며, 동기화 키워드를 지원해 동기로 처리합니다. 그렇기 때문에 Multiple thread 환경에서 안전하다는 특징이 있습니다. (thread safe)

</br>

### 동기화? 비동기화?

1. **동기(Synchronous)** 는 요청과 그 결과가 동시에 일어난다는 것, 즉 요청을 하면 시간이 얼마가 걸리든지 요청한 자리에서 결과가 주어져야 하는 것을 의미합니다. 설계가 매우 간단하고 직관적이라는 장점이 있습니다. 하지만 결과가 주어질 때까지 아무 것도 못하고 대기해야한다는 단점이 있습니다. 

   :heavy_plus_sign: Java의 `synchronized` 키워드 : 자바에서 멀티 스레드 접근을 제한하는 키워드로, 메소드 단위, 블록 단위에 적용이 가능합니다. 하지만, 메소드 단위로 지정할 경우 메소드 전체에 Lock이 걸리기 때문에 가능하면 블록을 활용하는 것이 좋습니다. (임계영역은 작을수록 좋기 때문.)

2. **비동기(Asynchronous)** 는 요청과 결과가 동시에 일어나지 않는다는 것, 즉 요청한 그 자리에서 결과가 주어지지 않는 것을 의미합니다. 결과가 주어지는데에 시간이 걸리더라도 그 시간동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있다는 장점이 있지만, 동기보다 복잡하다는 단점이 있습니다. 

   예) Ajax

</br>

### ==와 equals()의 차이?

1. `==`은 항등 *연산자*로, 참조 비교 즉, 두 객체가 같은 메모리 공간을 가리키는지 확인합니다. 반환 형태는 `boolean` type이며, 모든 primitive type에 적용가능합니다.
2. `equals()`는 객체 비교 *메소드*로, 내용 비교 즉, 두 객체의 값이 같은지 확인합니다. (예를 들어 문자열이라면 문자열의 데이터/내용을 기반으로 비교) 또, primitive type에 대해서는 적용할 수 없으며, 반환 형태는 `boolean` type 입니다.

</br>

### Java Reflection(리플렉션)?

이미 로딩이 완료된 클래스에서 *또 다른 클래스를 동적으로 로딩(Dynamic Loading)* 하여 생성자, 멤버 필드, 그리고 멤버 메서드 등을 사용할 수 있도록 하는 기능을 말합니다. 즉, 컴파일 시간(Compile Time)이 아니라 실행 시간(Run Time)에 동적으로 특정 클래스의 정보를 객체화를 통해 분석 및 추출해낼 수 있는 프로그래밍 기법이라고 표현할 수 있습니다.

자바의 리플렉션으로는 클래스의 패키지 정보, 접근 지정자, 수퍼 클래스, 어노테이션 등도 얻을 수 있습니다.

**:heavy_plus_sign: 어떻게 사용?**

`Class.forName("클래스이름").newInstance`와 같은 코드처럼 클래스의 이름으로부터 인스턴스를 생성할 수 있고, 이를 이용하여 클래스의 정보를 가져올 수 있습니다. (메서드 이름으로도 호출 가능합니다.)

**:heavy_plus_sign: 왜 사용?**

Run Time에 다른 클래스를 동적으로 로딩하여 접근할 때, 클래스와 멤버 필드 그리고 메서드 등에 관한 정보를 얻어야 할 때 사용됩니다. 리플렉션이 없더라도 완성도 높은 코드를 구현할 수 있지만, 사용한다면 좀 더 유연한 코드를 만들 수 있습니다.

**:heavy_plus_sign: 주의할 점?**

외부에 공개되지 않는 `private` 멤버도 접근과 조작이 가능하므로 주의해야합니다.

### 생성자?

생성자란 객체화 할 때 초기화 해주는 역할을 담당한다.

**특징**
+ 클래스에는 반드시 생성자가 존재해야 한다.
+ 인스턴스 생성시 딱 한번 호출된다.
+ 인스턴스 변수의 초기화가 목적이다.
+ 클래스 이름과 동일한 이름을 가진 메소드다.
+ 반환형이 존재하지 않는다.


**조건**
1. 클래스 명과 메소드 명이 동일해야 한다.
2. 리턴 타입이 없어야 한다.

**생성자가 없어도 클래스를 생성할 수 있다. 이유는?**

생성자가 존재하지 않으면 스스로 default 생성자를 만든다.

### this vs super

this와 this(), super와 super()는 맥락은 같지만 쓰임새가 다르다.

**this**

+ 현재 클래스의 인스턴스를 의미
+ 즉, 현재 클래스의 멤버변수를 지정할 때 사용한다.
+ 아래와 같이 현재 클래스의 클래스 변수 mother와 동일한 이름의 파라미터(setMother 메소드)가 들어올 경우, 명확히 구분할 수 있다.

![image](https://user-images.githubusercontent.com/33089715/117761669-bf3e4380-b262-11eb-9351-fb4911c594a8.png)


**this()**

+ 현재 클래스에 정의된 생성자를 부를 때 사용된다.
+ 아래와 같이 ParentClass의 생성자가 2개 있을 경우, 생성자 값이 들어오지 않을 경우 this() 메소드를 사용하여 두 번째 생성자를 불러 초기화 할 수 있다.

![image](https://user-images.githubusercontent.com/33089715/117761672-c2393400-b262-11eb-9cec-38132fc0fa81.png)

**super**

+ 자식 클래스에서 상속받은 부모 클래스의 멤버 변수를 참조할 때 사용한다.

![image](https://user-images.githubusercontent.com/33089715/117761681-c49b8e00-b262-11eb-911f-b0842f3d9e8f.png)

**super()**
+ 자식 클래스가 자신을 생성할 때 부모 클래스의 생성자를 불러 초기화 할 때 사용된다.(기본적으로 자식 클래스의 생성자에 추가된다.)
+ super() 사용예제
    + ChildClass객체 생성시(ChildClass child = new ChildClass) 호출 순서 
        + ChildClass() 생성자 호출  
        - this()에 의하여, ChildClass(String, String) 생성자 호출
        - super()에 의하여, ParentClass(String, String) 생성자 호출
        - ChildClass 객체 생성 완료!


    ![image](https://user-images.githubusercontent.com/33089715/117761690-c5ccbb00-b262-11eb-9128-6bad24305452.png)
    
    실행결과
    
    ![image](https://user-images.githubusercontent.com/33089715/117762168-97031480-b263-11eb-9ed4-10c3549a3038.png)

 
</br>

## Object Oriented Programming

### OOP의 4가지 특징?

추상화, 캡슐화, 상속성, 다형성이 있습니다.

1. 먼저, **추상화**(Abstraction)은 구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루는 것, 불필요한 정보는 제거하고 중요한 개념만 모델화(개략화)하는 것을 말합니다.

2. **캡슐화**(Encapsulation)는 객체의 속성과 메소드를 하나로 묶는 것으로, 높은 응집도, 낮은 결합도를 유지하여 유연함과 유지보수성을 증가시킬 수 있습니다.

   :heavy_plus_sign: **정보 은닉**: 데이터를 외부에서 직접 접근하지 못하도록 제한하는 것을 의미합니다. (함수를 통해서만 접근)

3. **상속성**(Inheritance)은 자식 클래스가 부모 클래스의 특성과 기능을 물려받는 것을 말하며, 캡슐화를 유지하고 클래스의 재사용을 용이하도록 해줍니다.

4. **다형성**(Polymorphism)은 서로 다른 클래스의 객체가 같은 메시지를 받았을 때, 각자의 방식으로 동작하는 특징을 말합니다. (예: 오버라이딩)

### OOP의 5대 (설계)원칙

SOLID원칙입니다.

1. **S**는 단일 책임 원칙(Single Responsibility Principle)으로, 객체는 단 하나의 책임만 가져야 한다는 것을 의미합니다.
2. **O**는 개방-폐쇄 원칙(Open Closed Principle)으로, 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다는 것을 의미합니다.
3. **L**은 리스코프 치환 원칙(Liskov Substitution Principle)으로, 일반화 관계에 대한 이야기로, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 것을 의미합니다.
4. **I**는 인터페이스 분리 원칙(Interface Segregation Principle)으로, 인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙을 의미합니다.
5. **D**는 의존 역전 원칙(Dependency Inversion Principle)으로, 의존 관계를 맺을 때 변화하기 쉬운 것, 또는 자주 변화하는 것보다 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것을 의미합니다.

</br>

### 절차 지향 vs 객체 지향 vs 함수형?

1. **절차 지향 프로그래밍**은 일이 진행되는 순서대로 프로그래밍 하는 방법입니다. C가 대표적입니다. 

   코드를 따라가며 읽기가 쉬우며 작성하기 쉽고, 컴퓨터의 처리 구조와 비슷해 실행 속도가 빠르다는 장점이 있습니다. 하지만 각각의 코드가 순서에 민감하게 연결되어 있어 유지보수가 쉽지 않고, 프로그램을 분석하기 어렵다는 단점이 있습니다.

2. **객체 지향 프로그래밍**은 객체를 먼저 작성하고 함수를 작성하는 형태로, 데이터(객체)를 먼저 디자인하고 데이터에 맞는 메소드를 구현하는 방식입니다. 객체 지향의 핵심은 연관되어 있는 변수와 메서드를 하나의 그룹으로 묶어서 Grouping하는 것입니다. Java가 대표적입니다.

   "~는 ~이다"와 같이 사람의 사고와 가장 비슷하게 프로그래밍하기 위해 생성된 기법이며, 코드의 재사용이 가능하다는 장점이 있습니다. (하나의 클래스를 바탕으로 서로 다른 상태를 가진 인스턴스를 만들면 서로 다른 행동을 하게 된다. 즉, 하나의 클래스가 여러 개의 인스턴스가 될 수 있다는 점이 객체 지향이 제공하는 가장 기본적인 재활용성이라고 할 수 있다.)

   하지만, 처리 속도가 상대적으로 다소 느리며, 설계에 많은 시간이 소요되며, 테스트가 어렵다는 단점이 있습니다.

:heavy_plus_sign: 절차 지향은 데이터 중심, 객체 지향은 기능 중심.

3. 함수형 프로그래밍은 함수를 먼저 작성하고, 함수에 맞는 데이터를 세팅하는 방식입니다. 

   side effect를 미연에 방지할 수 있고, 객체 지향보다 코드가 간결하며, 테스트가 쉽고, 데이터형에 구애받지 않는다는 장점이 있습니다. 

   하지만, 상태를 조작할 수 없다는 단점이 있습니다.

## 기타
### 쓰레드 풀?
JVM은 쓰레드 생성 개수 제한이 없어서 계속해서 쓰레드를 만들게 되면 성능 저하와 메모리 부족 문제가 생길 수 있다. 이것을 막기 위해 쓰레드 풀이라는 쓰레드 관리 방식이 사용된다. 쓰레드를 허용된 개수 안에서만 사용할 수 있도록 제약하는 방식이다. 어플리케이션에서 사용자로부터 들어온 요청을 작업 큐에 넣고 스레드 풀은 작업 큐에 들어온 Task를 미리 생성해놓은 Thread 들에게 할당한다. 일을 다 처리한 Thread 들은 다시 어플리케이션에 결과값을 리턴하는 방식이다. 이용하는 이유는 프로그램 성능 저하 방지, 다수의 사용자 요청을 처리하기 위해 사용된다.

