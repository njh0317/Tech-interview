# Deadlock
프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로 교착 상태라고도 하며, 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.

## 교착상태 필요 조건
필요 조건 이므로, 네 가지가 모두 해당된다고 해서 반드시 교착상태가 일어나 것은 아니고, 일어날 확률이 생기는 것이다.

### Mutual exclusion(상호 배타)
한 프로세스가 자원을 사용하고 있다면, 다른 프로세스는 이 자원을 사용할 수 없다.
- 젓가락은 한 철학자가 사용하고 있으면 이 젓가락은 사용할 수 없으므로 상호배타적이다.

### Hold and wait(보유 및 대기)
한 프로세스가 자원을 가지고 있는 상태에서 대기한다.
- 철학자는 왼쪽 젓가락을 가지고 있는 상태에서 오른쪽 젓가락을 집기 위해 대기한다.

### No Preemption(비선점)
한 프로세스가 자원을 수행하는 중에는 다른 프로세스가 중간에 끼어들 수 없다.
- 한 철학자가 젓가락을 집은 상태에서 다른 철학자가 이 젓가락을 뺏을 수 없다.

### Circular wait(환형 대기)
프로세스가 요구하는 자원의 방향이 원형을 이룬다.
- 모든 철학자는 왼쪽 젓가락부터 집을 수 있다.

## 교착상태 해결 방법
### 예방(Prevention)
교착상태 방지는 위에서 살펴본 교착상태 필요조건 네 가지 중 최소 한 가지를 만족시키지 않도록 만드는 것이다. 자원의 낭비가 심하다는 단점이 있다.

+ **상호배타(Mutual exclusion)**: 상호배타를 없애기 위해서는 자원을 공유 가능하게 만들어야 한다. 하지만 현실적으로 이러한 방법이 불가능한 경우가 많다.
+ **보유 및 대기(Hold & Wait)**: 이 조건을 없애려면 자원을 가지고 있는 상태에서 다른 자원을 기다리지 않도록 만든다. 만약 여러 개의 자원이 필요하다면 필요한 모든 자원을 얻을 수 있는 경우에만 해당 자원을 요청한다. 또는 필요한 자원 중 일부만 가지는 경우 할당받은 자원을 모두 운영체제에 반납한다. 하지만 이와 같은 방법은 자원의 활용률을 저하시키고, starvation 현상이 발생하는 단점이 있다.
+ **비선점(No preemption)**: 비선점을 없애러면 반대로 선점이 가능하도록 만들어야 한다. 이 역시 대부분의 자원에게는 불가능한 방법이다. CPU는 강제로 스위칭하는 것이 가능한 경우가 있지만, 대부분의 경우에는 불가능하다. 가령 프린터를 수행하는 중간에 다른 프로세스가 이를 선점하는 것은 불가능하다고 볼 수 있다.
+ **환형대기(Circular wait)**: 이 조건을 없애는 것은 위 세 가지 조건보다는 할 수 있는 확률이 높다. 대표적인 예는 모든 자원에 번호를 부여하여 이 번호에 대한 오름차순으로 자원을 요청하는 것이다. 이 역시 자원의 활용률을 저하시키는 단점이 있다.

### 회피(Avoidance)
Deadlock의 가능성을 알고, 발생 가능성을 미리 판단하여 프로세스를 제어하는 방법이다.

**Banker's Algorithm이란?**
교착상태 회피 방법 중 하나로, 프로세스가 자원을 요구할 댸 시스템이 자원을 할당한 후 안정상태로 남아있게 되는지를 사전에 검사하여 교착상태를 회피한다.
+ 시스템이 자원을 할당하 후에도 안정 상태로 남아있는지 검사하여 안정상태에 있으면 자원을 할당하고 그렇지 않으면 다른 프로세스들이 자원을 해제할 때까지 대기한다.

+ 자료구조
    ![image](https://user-images.githubusercontent.com/33089715/117638586-f4448a80-b1bd-11eb-9483-823111f2bd90.png)
+ 예시
    ![image](https://user-images.githubusercontent.com/33089715/117638803-3241ae80-b1be-11eb-99d1-2c6c2987605e.png)

    + 안정상태이다.
    + 현재 Available 자원이 [3, 3, 1]인데 P1, P2에는 할당할 수 없지만 P3 프로세스에 할당하여 프로세스 P3을 실행한 후 할당된 자원을 해제하면 Available 자원은 [5, 4, 4]가 된다. 따라서 안정상태이다.
+ 단점

    + 할당할 수 있는 자원의 수가 일정해야 한다.
    + 사용자 수가 일정해야 한다.
    + 항상 불안정 상태를 방지해야 하므로 자원 이용도가 낮다.

### 검출 및 복구(Detection & Recovery)
Deadlock을 허용하고, 교착상태가 발생했음을 인지하고 조치하는 방법이다.

**검출**
- 자원 할당 그래프를 통해 교착 상태를 탐지할 수 있다.
- 주기적으로 교착상태가 발생하였는지 검사하고 복구한다.
    - 주기 길이가 짧으면 오버헤드 증가
    - 주기가 길면 오버헤드 줄지만 복구 가능성 낮음

**자원 할당 그래프란?**

어떤 자원이 어떤 프로세스에 할당되었는지 또는 어느 프로세스가 어느 자원을 할당 받으려고 기다리는지 그림으로 나타낸 것이다. 교착상태를 검출할 수 있다.
+ 자원 : 사각형
+ instance : 점
+ 프로세스 : 원
+ 할당 : 화살표
![image](https://user-images.githubusercontent.com/33089715/117639517-f824dc80-b1be-11eb-810d-752aab71a9a8.png)
+ 교착상태의 필요 조건을 한 눈에 볼 수 있다.
+ mutual exclusion과 no-preemption은 기본적으로 적용된다.
+ Hold and wait는 화살표를 통해 한 프로세스가 인스턴스를 할당받았고, 다른 자원을 가리키고 있는 상태이다.
+ 화살표 방향이 원형을 이루고 있다면 Circular wait 상태이다.

**복구**
- 복구 방법으로는 주기적으로 메모리에 상태를 저장해 놓다가 교착상태 발생 시 그 이전 상태로 되돌리는 방법이 있다. 일부 프로세스를 강제로 종료하거나 자원을 강제로 선점하여 프로세스에게 할당해주는 방법 등이 있다.
    - 자원 선점시 고려사항
        1. 자원을 선점할 프로세스 선택 문제 : 최소의 피해를 줄 수 있는 프로세스 선택
        2. 자원을 선점한 프로세스의 복귀 문제 : 자원이 부족한 상태이므로 대부분 일시중지 시키고 다시 시작하는 방법을 사용한다.
        3. 기아 현상 문제 : 한 프로세스가 계속하여 자원 선점 대상이 되지 못하도록 고려해야 한다.
- 복구를 제대로 못할 수도 있고, 검출을 위해 추가적인 오버헤드가 발생한다는 단점이 있다.

### 무시(Ignore)

### 식사하는 철학자 문제에서 교착상태를 해결할 수 있는 방법?
1. n 명이 앉을 수 있는 테이블에서 철학자를 n-1 명만 앉힌다.
2. id가 홀수인 철학자는 오른쪽 부터, id가 짝수인 철학자는 왼쪽부터 집음으로서 circular wait를 를 만족시키지 않도록 한다.
