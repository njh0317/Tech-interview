# Database

데이터베이스는 파일 시스템과 달리 1) 실시간 접근성, 2) 계속적인 변화, 3) 동시 공유, 4) 내용에 따른 참조 의 특징을 가진다. 

1. [데이터베이스 풀](#데이터베이스-풀)
   * [Connection Pool](#connection-pool)
   * [DB에 접근하는 단계](#db에-접근하는-단계)
   * [Connection이 부족하면?](#connection이-부족하면)
   * [왜 사용할까?](#왜-사용할까)
   * [Thread Pool](#thread-pool)
   * [Thread Pool과 Connection Pool](#thread-pool과-connection-pool)
2. [정규화](#정규화)
   * [정규화가 생겨난 배경](#정규화가-생겨난-배경)
   * [정규화(Nomalization)란?](#정규화nomalization란)
   * [제 1 정규화](#제-1-정규화)
   * [제 2 정규화](#제-2-정규화)
   * [제 3 정규화](#제-3-정규화)
   * [BCNF(Boyce-Codd) 정규화](#bcnfboyce-codd-정규화)
   * [정규화의 장점](#정규화의-장점)
   * [정규화의 단점](#정규화의-단점)
   * [반정규화(De-normalization, 비정규화)](#반정규화de-normalization-비정규화)
3. [트랜잭션](#트랜잭션)
   * [트랜잭션이란?](#트랜잭션이란)
   * [트랜잭션의 특징 (ACID)](#트랜잭션의-특징-acid)
   * [트랜잭션의 연산](#트랜잭션의-연산)
   * [트랜잭션의 상태](#트랜잭션의-상태)
   * [장애와 회복](#장애와-회복)
   * [회복 기법](#회복-기법)
   * [교착상태](#교착상태)
4. [JOIN (조인)](#join-조인)
   * [조인이란?](#조인이란)
   * [INNER JOIN](#inner-join)
   * [LEFT OUTER JOIN](#left-outer-join)
   * [RIGHT OUTER JOIN](#right-outer-join)
   * [FULL OUTER JOIN](#full-outer-join)
   * [CROSS JOIN](#cross-join)
   * [SELF JOIN](#self-join)
5. [인덱스(index)](#인덱스index)
   * [인덱스(Index)란?](#인덱스index란)
   * [인덱스의 동작](#인덱스의-동작)
   * [인덱스의 관리](#인덱스의-관리)
   * [인덱스의 장단점](#인덱스의-장단점)
   * [인덱스를 사용하면 좋은 경우](#인덱스를-사용하면-좋은-경우)
   * [인덱스의 자료구조](#인덱스의-자료구조)
6. [무결성](#무결성)
7. [키](#키)
8. [파티셔닝](#파티셔닝)
   * [파티셔닝이란?](#파티셔닝이란)
   * [파티셔닝의 목적](#파티셔닝의-목적)
   * [파티셔닝의 장점](#파티셔닝의-장점)
   * [파티셔닝의 단점](#파티셔닝의-단점)
   * [DB 파티셔닝의 종류](#db-파티셔닝의-종류)
   * [파티셔닝의 분할 기준](#파티셔닝의-분할-기준)
9. [샤딩](#샤딩)
   * [샤딩이란?](#샤딩이란)
   * [샤딩의 장점](#샤딩의-장점)
   * [샤딩의 단점](#샤딩의-단점)
   * [샤딩의 구조](#샤딩의-구조)
10. [ORM](#orm)
   * [영속성(Persistence)](#영속성persistence)
   * [ORM이란?](#ORM이란)
   * [ORM의 장점](#ORM의-장점)
   * [ORM의 단점](#ORM의-단점)
11. [JDBC](#jdbc)
    * [JDBC란?](#jdbc란)
    * [JDBC를 이용한 DB 접근](#jdbc를-이용한-db-접근)
12. [SQL vs NoSQL](#sql-vs-nosql)
   * []()
## 데이터베이스 풀

### Connection Pool

클라이언트의 요청에 따라 각 애플리케이션의 스레드에서 데이터베이스에 접근하기 위해서는 Connection이 필요하다. 이런 Connection을 여러 개 생성해 두어 저장해 놓은 공간(캐시), 또는 이 <u>공간</u>의 Connection을 필요할 때 꺼내 쓰고 반환하는 <u>기법</u>을 Connection Pool이라고 한다.

<img src="https://user-images.githubusercontent.com/33208360/117453378-d7227880-af7f-11eb-9dc9-f3fa76fce7a8.png" alt="image" style="zoom: 67%;" />

### DB에 접근하는 단계

1. 웹 컨테이너가 실행되면서 DB와 연결된 Connection 객체들을 미리 생성하여 Pool에 저장한다.
2. DB에 요청 시, Pool에서 Connection 객체를 가져와 DB에 접근한다.
3. 처리가 끝나면 다시 Pool에 반환한다.

### Connection이 부족하면?

모든 요청이 DB에 접근하고 있고 남은 Connection이 없다면, 해당 클라이언트는 대기 상태로 전환시키고 Pool에 Connection이 반환되면 대기 상태에 있는 클라이언트에게 순차적으로 제공된다.

### 왜 사용할까?

* 매 연결마다 Connection 객체를 생성하고 소멸시키는 비용을 줄일 수 있다.
* 미리 생성된 Connection 객체를 사용하기 때문에, DB 접근 시간이 단축된다.
* DB에 접근하는 Connection의 수를 제한하여, 메모리와 DB에 걸리는 부하를 조정할 수 있다.

### Thread Pool

* 비슷한 맥락
* 매 요청마다 요청을 처리할 Thread를 만드는 것이 아닌, 미리 생성한 Pool 내의 Thread를 소멸시키지 않고 재사용하여 효율적으로 자원을 활용하는 기법

### Thread Pool과 Connection Pool

* WAS(Web Application Server)에서 Thread Pool과 Connection Pool내의 Thread와 Connection의 수는 직접적으로 메모리와 관련있기 때문에, 많이 사용하면 할수록 메모리를 많이 점유하게 된다. 반대로 메모리를 위해 적게 지정한다면, 서버에서는 많은 요청을 처리하지 못하고 대기할 수 밖에 없다.
* 보통 WAS의 Thread의 수가 Connection의 수보다 많은 것이 좋다. 모든 요청이 DB에 접근하는 작업이 아니기 때문이다.

</br>

## 정규화

### 정규화가 생겨난 배경

한 릴레이션에 여러 엔티티의 속성들을 혼합하게 되면 정보가 중복 저장되며, 저장 공간을 낭비하게 된다. 또 중복된 정보로 인해 **이상 현상(Anomaly)** 이 발생하게 된다. 이러한 문제를 해결하기 위해 정규화 과정을 거치는 것이다.

**:heavy_plus_sign: 이상 현상**

* 삽입 이상 (insertion anomaly)

  원하지 않는 자료가 삽입된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제점

* 삭제 이상 (deletion anomaly)

  하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점

* 수정(갱신) 이상 (modification anomaly)

  정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어져 정확한 정보 파악이 되지 않는 문제점

### 정규화(Nomalization)란?

관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업이다. 구체적으로는 불만족스러운 나쁜 릴레이션의 속성들을 나누어 좋은 작은 릴레이션으로 분해하는 작업을 말한다.

정규화 과정을 거치게 되면 정규현을 만족하게 된다. 이때 '정규형'이란, 특정 조건을 만족하는 릴레이션의 스키마의 형태를 말하며, 제 1정규형, 제 2정규형, 제 3정규형, .. 등이 존재한다.

**:heavy_plus_sign: '좋은' 릴레이션과 나쁜' 릴레이션?**

엔티티를 구성하고 있는 속성 간에 함수적 종속성(Functional Dependency)을 판단한다. 판단된 함수적 종속성은 좋은 릴레이션 설계의 정형적 기준으로 사용된다.

즉, 각각의 정규형마다 어떠한 함수적 종속성을 만족하는지에 따라 정규형이 정의되고, 그 정규형을 만족하지 못하는 정규형을 나쁜 릴레이션으로 파악한다.

**:heavy_plus_sign: 함수적 종속성이란?**

속성 데이터들의 의미와 속성 간의 상호관계로부터 유도되는 제약 조건의 일종이다.

X와 Y를 임의의 속성 집합이라고 할 때, X의 값이 Y의 값을 유일하게(unique) 결정한다면, "X는 Y를 함수적으로 결정한다" 라고 한다. 

함수적 종속성은 실세계에서 존재하는 속성들 사이의 제약조건으로부터 유도된다. 또한 각종 추론 규칙에 따라서 속성간의 함수적 종속성을 판단할 수 있다.

**:heavy_plus_sign: 각각의 정규형은 어떤 조건을 만족해야 하는가?**

1. 분해의 대상인 분해 집합 D는 무손실 조인을 보장해야 한다.
2. 분해 집합 D는 함수적 종속성을 보존해야 한다.

### 제 1 정규화

속성의 **도메인이 오직 원자값**만을 포함하고, 튜플의 모든 속성이 도메인에 속하는 하나의 값을 가져야 한다. 즉, 복합 속성, 다중값 속성, 중첩 릴레이션 등 비원자적인 속성들을 허용하지 않는 릴레이션 형태를 말한다.

### 제 2 정규화

제 1 정규화를 진행한 테이블에 대해 기본키가 2개 이상의 속성으로 이루어진 경우, **부분 함수 종속성을 제거**해 기본키에 대해 완전 함수 종속을 만족해야한다.

완전 함수적 종속이란, `X->Y` 라고 가정했을 때 X의 어떤 속성이라도 제거하면 더이상 함수적 종속성이 성립하지 않는 경우를 말한다. 기본키의 부분집합이 결정자가 되어서는 안된다는 것을 의미한다.

즉, 키가 아닌 속성들이 각각 후보키에 대해 결정되는 릴레이션의 형태를 말한다.

### 제 3 정규화

제 2 정규화를 진행한 테이블에 대해 키가 아닌 모든 속성이 기본키에 대해서 **이행적 종속을 제거**해 이행적 종속되지 않아야 한다. 

이행적 종속이란, `X->Y`, `Y->Z`가 성립할 때 `X->Z`가 성립되는 것을 의미한다.

즉, 키가 아닌 속성들이 키가 아닌 속성에 의해 종속되는 경우가 없는 릴레이션의 형태를 말한다.

### BCNF(Boyce-Codd) 정규화

제 3 정규화를 진행한 테이블에 대해 모든 **결정자가 후보키**가 되도록 테이블을 분해하는 것이다. (여러 후보키가 존재하는 릴레이션에 해당)

:heavy_plus_sign: 수많은 정규형이 있지만 관계 데이터베이스 설계의 목표는 각 릴레이션이 3NF 또는 BCNF를 갖게 하는 것이다.

### 정규화의 장점

1. 데이터베이스 변경 시, 이상 현상(Anomaly) 제거

2. 데이터베이스 구조 확장 시 재 디자인 최소화

   정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다. 이는 데이터베이스와 연동된 응용 프로그램에 최소한의 영향만 미치게 되며 응용프로그램의 생명을 연장시킨다.

3. 사용자에게 데이터 모델을 더욱 의미있게 제공

   정규화된 테이블들과 정규화된 테이블들 간의 관계들은 현실 세계에서의 개념들과 그들간의 관계를 반영한다.

### 정규화의 단점

릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아진다. 이로 인해 Query에 대한 응답 시간이 느려질 수 있다.

(정규화를 수행하므로써 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다. 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다.)

### 반정규화(De-normalization, 비정규화)

조회를 하는 SQL 문장에서 JOIN이 많이 발생하여 이로 인한 성능 저하가 나타나는 경우에 반정규화를 적용하는 전략이 필요하다.

**1) 반정규화**

정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법 중 하나이다. 

디스크 I/O량이 많아서 조회 시 성능이 저하되거나, 테이블끼리의 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되거나, 컬럼을 계산하여 조회할 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다.

일반적으로 조회에 대한 처리 성능이 중요하다고 판단될 때 부분적으로 반정규화를 고려하게 된다.

**2) 반정규화의 대상**

* 자주 사용되는 테이블에 엑세스하는 프로세스의 수가 가장 많고, 항상 일정한 범위만을 조회하는 경우
* 테이블에 대량 데이터가 있고, 대량의 범위를 자주 처리하는 경우, 성능상 이슈가 있을 경우
* 테이블에 지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 어려울 경우

**3) 반정규화 과정에서 주의할 점은?**

반정규화를 과도하게 적용하다 보면 데이터의 무결성이 깨질 수 있다. 또한, 입력, 수정, 삭제의 Query문에 대한 응답 시간이 늦어질 수 있다.

</br>

## 트랜잭션

### 트랜잭션이란?

하나의 작업을 수행하기 위해 필요한 데이터베이스의 연산들을 모아놓은 것으로, 데이터베이스에서 논리적인 작업의 단위이며 장애가 발생했을 때 데이터를 복구하는 작업의 단위이다.

* 데이터베이스는 정확한 데이터를 유지하고 오류 발생시 빠르게 복구하며 데이터베이스가 항상 정확하고 일관된 상태를 유지할 수 있도록 다양한 기능을 제공하는데, 그 중 가장 중요한 역할을 하는 것이 트랜잭션이다.

### 트랜잭션의 특징 (ACID)

트랜잭션이 성공적으로 처리되어 데이터베이스의 무결성과 일관성을 보장하려면 4가지 특성을 만족해야한다.

1. **Atomicity (원자성)**

   트랜잭션을 구성하는 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야한다는 All-or-Nothing 방식을 의미한다. 트랜잭션을 수행하다가 장애가 발생하여 작업을 완료하지 못했다면, 지금까지 실행한 연산들 모두 취소하고 데이터베이스를 트랜잭션 작업 전의 상태로 되돌려 원자성을 보장한다.

2. **Consistency (일관성)**

   트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관성 있는 상태를 유지해야함을 의미한다. 즉, 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태였다면 트랜잭션의 수행이 완료된 후 결과를 반영한 데이터베이스도 일관된 상태가 되어야 한다.

3. **Isolation (격리성)**

   현재 수행 중인 트랜잭션이 완료될 때까지 트랜잭션이 생성한 중간 연산 결과에 다른 트랜잭션들이 접근할 수 없음을 의미한다. 시스템에서 여러 트랜잭션이 동시에 수행되지만 각 트랜잭션이 독립적으로 수행될 수 있도록 다른 트랜잭션의 연산 중간에 서로 접근하지 못하게 한다.

4. **Durability (지속성)**

   트랜잭션이 성공적으로 완료된 후 데이터베이스에 반영된 수행 결과는 어떠한 경우에도 손실되지 않고 영구적이어야함을 의미한다. 시스템에 장애가 발생하더라도 트랜잭션 작업 결과는 없어지지 않고 데이터베이스에 그대로 남아있어야 한다.

### 트랜잭션의 연산

1. **commit 연산**

   트랜잭션이 성공적으로 수행되었을 때 선언한다(작업 완료). commit 연산이 실행된 후에야 트랜잭션의 수행 결과가 데이터베이스에 반영되어 데이터베이스가 일관된 상태를 지속적으로 유지한다. (commit 연산의 실행을 통해 트랜잭션의 수행이 성공적으로 완료되었음을 선언하고 결과를 최종 데이터베이스에 반영한다.)

2. **rollback 연산**

   트랜잭션이 수행을 실패했음을 선언한다(작업 취소). rollback연산이 실행되면 트랜잭션이 지금까지 실행한 연산의 결과가 취소되고 트랜잭션이 수행되기 전의 상태로 다시 돌아간다. (트랜잭션이 수행되는 도중 일부 연산이 처리되지 못한 상황에서는 rollback 연산을 실행하여 트랜잭션의 수행이 실패했음을 선언하고, 모순되지 않도록 데이터베이스를 트랜잭션 수행 전의 일관된 상태로 되돌려야 한다.)

### 트랜잭션의 상태

트랜잭션의 연산을 수행할 때 크게 5가지의 상태가 존재한다.

<img src="https://user-images.githubusercontent.com/33208360/117567248-55a12680-b0f6-11eb-9002-a4e71bdbf047.png" alt="image" style="zoom: 33%;" />

1. 활동(Active) 상태

   트랜잭션이 수행을 시작해 현재 수행 중인 상태.

2. 부분 완료(Partially Committed) 상태

   마지막 연산이 실행된 직후의 상태를 부분 완료한 상태. 연산은 모두 처리한 상태이지만 수행한 최종 결과를 아직 데이터베이스에 반영하지 않은 상태.

3. 완료(Committed) 상태

   트랜잭션이 성공적으로 완료되어 commit 연산을 실행한 상태.

4. 실패(Failed) 상태

   장애가 발생하여 트랜잭션의 수행이 중단된 상태.

5. 철회(Aborted) 상태

   수행이 실패하여 rollback 연산을 실행한 상태.

### 장애와 회복

데이터베이스는 모순이 없는 일관된 상태로 유지되야 한다. 그래서 장애가 발생했을 시 회복 기능을 제공해 관리되어진다. 

여기서 회복이라 함은 장애가 발생했을 때 데이터베이스를 장애가 발생하기 전의 일관된 상태로 복귀시키는 것을 의미한다.

**:heavy_plus_sign: 데이터베이스에서의 장애**

크게 3가지 유형이 존재한다.

1. 트랜잭션 장애
2. 시스템 장애: 하드웨어 결함으로 정상적으로 수행을 계속할 수 없는 경우
3. 미디어 장애: 디스크 장치의 결함으로 디스크에 저장된 데이터베이스의 일부 혹은 전체가 손상된 상태

### 회복 기법

크게 4가지가 존재하고, 데이터베이스 관리 시스템에 있는 회복 관릭자가 담당하게 된다. 회복 관리자는 장애 발생을 탐지하고, 장애가 탐지되면 데이터베이스를 복구하는 기능을 제공한다.

1. **Immediate Updates (즉시 갱신)**

   로그 기반 회복 기법. 

   트랜잭션 수행 도중 변경하면 변경 정보를 로그 파일에 저장하고, 트랜잭션이 부분 완료되기 전에이라도 모든 변경 내용을 즉시 데이터베이스에 반영하는 기법. 

   모든 변경 내용을 즉시 데이터베이스에 반영하는 기법이다. (로그 파일을 참조하여 REDO & UNDO 연산 모두 실행)

2. **Deferred Updates (지연 갱신)**

   로그 기반 회복 기법.

   트랜잭션이 부분 완료 상태에 이르기까지 발생한 모든 변경내용을 로그 파일에만 저장하고 데이터베이스에는 커밋이 발생할 때 저장하는 기법.

   회복 과정에서 UNDO가 필요없으며, 이를 통해 트랜잭션의 원자성을 보장한다.

3. **Checkpoint Recovery**

   이전은 신경쓰지 않고 Checkpoint 이후만 즉시 갱신 혹은 지연 갱신을 수행한다.

   가장 최근 Checkpoint 지점을 찾아 그 시점 이후의 로그만을 회복 대상으로 한다.

4. **Media Recovery**

   디스크와 같이 비휘발성 저장 장치의 내용이 손상되는 장애가 발생했을 시에 회복을 위한 기법이며, 백업, 미러링 등을 이용해 복구한다.

**:heavy_plus_sign: How to recover?**

1. **Copy (duplicate)**

   * Dump

     데이터베이스 전체를 다른 저장 장치에 주기적으로 복사하는 방법. 디스크와 같은 비휘발성 저장 장치에 데이터베이스 복사본을 저장한다.

   * Log

     변경 연산이 실행될 때마다 데이터를 변경하기 이전 값과 변경된 이후의 값을 별도의 파일에 기록하는 방법이다.

2. **REDO, UNDO 연산 실행**

   * REDO(재실행)

     가장 최근에 저장한 데이터베이스 복사본을 가져온 후 로그를 이용해 복사본이 만들어진 이후에 실행된 모든 변경 연산을 재실행하여 장애가 발생하기 직전의 상태로 복구한다. 

     전반적으로 손상된 경우에 주로 사용한다.

   * UNDO (취소)

     로그를 이용해 지금까지 실행된 모든 변경 연산을 취소하여 데이터베이스를 원래의 상태로 복구한다.

     변경중이었거나 이미 변경된 내용만 신뢰성을 잃은 경우에 주로 사용한다.

### 교착상태

복수의 트랜잭션을 사용하다 보면 교착상태가 일어날 수 있다. 두 개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데, 이를 **교착상태**라고 한다.

**:heavy_plus_sign: 교착상태의 빈도를 낮추는 방법**

* 트랜잭션을 자주 커밋한다.
* 정해진 순서로 테이블에 접근한다. (트랜잭션들이 동일한 테이블 순으로 접근하게 한다.)
* 읽기 잠금 획득(`SELECT ~ FOR UPDATE`)의 사용을 피한다.
* 한 테이블의 복수 행을 복수의 연결에서 순서없이 갱신하면 교착상태가 발생하기 쉽다. 이 경우에는 테이블 단위의 잠금을 획득해 갱신을 직렬화하면 동시성은 떨어지지만 교착상태를 회피할 수 있다.

</br>

## JOIN (조인)

### 조인이란?

두 개이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법이다. 여러 개의 테이블을 마치 하나의 테이블인 것처럼 활용하는 방법이다.

보통 Primary key 또는 Foreign key 로 두 테이블을 연결한다. 테이블을 연결하려면 적어도 하나의 컬럼은 서로 공유되고 있어야 한다.

### INNER JOIN

쉽게 말해 교집합이다. 기준 테이블과 JOIN한 테이블의 중복된 값을 보여준다. 결과값은 A 테이블과 B 테이블이 모두 가지고 있는 데이터만 검색된다.

### LEFT OUTER JOIN

기준 테이블의 값 + 테이블과 기준테이블의 중복된 값을 보여준다. 왼쪽 테이블을 기준으로 JOIN한 경우이다. 왼쪽 테이블 A, 오른쪽 테이블 B를 조인했을 때 결과값은 A테이블의 모든 데이터와 A테이블과 B테이블의 중복되는 값이 검색된다.

### RIGHT OUTER JOIN

LEFT OUTER JOIN의 반대이다. 오른쪽 테이블을 기준으로 JOIN한 경우이다. 결과값은 B테이블의 모든 데이터와 A테이블과 B테이블의 중복되는 값이 검색된다.

### FULL OUTER JOIN

쉽게 말해 합집합이다. A테이블이 가지고 있는 데이터, B테이블이 가지고 있는 데이터 모두 검색된다. 기준 테이블의 의미가 없다.

### CROSS JOIN

모든 경우의 수를 전부 표현해주는 방식이다. 기준 테이블이 A일 경우, A의 데이터의 한 row를 B테이블 전체와 JOIN하는 방식이다. A테이블의 튜플 N개, B테이블의 튜플 M개일 때 결과값은 `N*M`개가 된다.

### SELF JOIN

자기자신과 자기자신을 조인하는 방식이다. 하나의 테이블을 여러번 복사해서 조인하는 것이다. 자신이 가지고 있는 컬럼을 다양하게 변형시켜 활용할 경우에 자주 사용한다.

</br>

## 인덱스(Index)

### 인덱스(Index)란?

추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다. (책의 색인과 같다.)

데이터베이스에서 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다.

<img src="https://user-images.githubusercontent.com/33208360/117781003-21a33e00-b27b-11eb-9823-1d86d2f8f8a1.png" alt="image" style="zoom:67%;" />

인덱스를 활용하면, 데이터를 조회하는 `SELECT` 외에도 `UPDATE`나 `DELETE`의 성능이 함께 향상된다. 해당 연산을 수행하려면 해당 대상을 조회해야만 작업을 할 수 있기 때문이다.

인덱스를 사용하지 않은 컬럼을 조회해야 하는 상황이라면 전체를 탐색하는 Full Scan을 수행해야한다. Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.

### 인덱스의 동작

1. Index Table에서 `where`에 포함된 값을 검색한다.
2. 해당 값의 table_id PK를 획득한다.
3. 가져온 tabel_id PK값으로 원본 테이블에서 값을 조회

### 인덱스의 관리

DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 그렇기 때문에 인덱스가 적용된 컬럼에 `INSERT`, `UPDATE`, `DELETE`가 수행된다면 각각 연산을 추가적으로 해주어야하며 그에 따른 오버헤드가 발생한다.

* `INSERT` : 새로운 데이터에 대한 인덱스를 추가한다.
* `DELETE` : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행한다.
* `UPDATE` : 기존의 인덱스를 사용하지 않음으로 처리하고, 갱신된 데이터에 대해 인덱스를 추가한다.

### 인덱스의 장단점

**장점**

* 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
* 전반적인 시스템의 부하를 줄일 수 있다.

**단점**

* 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.

* 인덱스를 관리하기 위해 추가 작업이 필요하다.

* 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.

  (만약, `INTERT`, `DELETE`, `UPDATE`가 빈번한 속성에 인덱스를 걸면, 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다. `UPDATE`와 `DELETE`는 기존의 인덱스를 삭제하지 않고 '사용하지 않음'처리를 해주기 때문에, 만약 어떤 테이블에 `UPDATE`와 `DELETE`가 빈번하게 발생된다면 실제 데이터보다 인덱스의 크기가 더 커져 SQL문 처리 시에 오히려 성능이 떨어지게 될 것이다.)

  (`INSERT`는 테이블에는 입력 순서대로 저장되지만, 인덱스 테이블에는 정렬하여 저장하기 때문에 성능 저하가 발생한다.)

### 인덱스를 사용하면 좋은 경우

* 규모가 작지 않은 테이블
* `INSERT`, `UPDATE`, `DELETE`가 자주 발생하지 않는 컬럼
* `JOIN`이나 `WHERE` 또는 `ORDER BY`에 자주 사용되는 컬럼
* 데이터의 중복도가 낮은 컬럼('성별'과 같은 경우 인덱스는 무용지물)

인덱스를 사용하는 것 만큼이나 생성된 인덱스를 관리해주는 것도 중요하다. 그렇기 때문에 사용하지 않는 인덱스는 바로 제거해주어야 한다.

### 인덱스의 자료구조

가장 대표적인 **해시 테이블**과 **B+ Tree**가 있다.

1. **해시 테이블 (Hash Table)**

   `(Key, Value)`로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용하다. 해시 테이블은 Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조이다.

   <img src="https://user-images.githubusercontent.com/33208360/117782974-17823f00-b27d-11eb-89a8-c5ea3cc8ad15.png" alt="image" style="zoom:50%;" />

   해시 테이블 기반의 DB 인덱스는 `(데이터=컬럼의 값, 데이터의 위치)`를 `(Key, Value)`로 사용하여 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현하였다.

   시간 복잡도는 `O(1)`이며, 매우 빠른 검색을 지원한다.

   하지만 DB 인덱스에서 해시 테이블이 사용되는 경우는 제한적인데, 그러한 이유는 해시가 등호(`=`) 연산에만 특화되었기 때문이다. 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 부등호 연산(`<`, `>`)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다.

   => 이러한 이유로 데이터베이스의 인덱스에서는 B+ Tree가 일반적으로 사용된다.

2. **B+ Tree**

   DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. B+ Tree는 모든 노드에 데이터(Value)를 저장했던 B-Tree와 다른 특성을 가지고 있다.

   * 리프 노드(데이터 노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스 노드)들은 데이터를 위한 인덱스(Key)만을 갖는다.
   * 리프노드들은 LinkedList로 연결되어 있다.
   * 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.

   데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있다. 이러한 이유로 B-Tree의 리프노드들을 LinkedList로 연결하여 순차 검색을 용이하게 하는 등 B-Tree를 인덱스에 맞게 최적화하였다.

   (물론, Best Case에 대해 리프노드까지 가지 않아도 탐색할 수 있는 B-Tree에 비해 무조건 리프노드까지 가야한다는 단점도 있다.)

   이러한 이유로 비록 B+ Tree는 `O(logn)`(밑이 `2`)의 시간복잡도를 갖지만 해시테이블보다 인덱싱에 더욱 적합한 자료구조가 되었다.

</br>

## 무결성

무결성이란, 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말한다. 

데이터의 무결성을 유지하기 위해 DBMS에서는 크게 4가지 종류로 구분한다.

1. 개체 무결성: 기본키로 선택된 필드는 null값을 허용하지 않는다.
2. 참조 무결성: 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지한다.
3. 도메인 무결성: 테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로 올바른 데이터가 입력됬는지를 체크하는 것이다. 
4. 고유 무결성: 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 그 속성값은 모두 고유한 값을 가진다. 같으면 안된다는 것.
5. NULL 무결성: 특정 속성값에 NULL이 올 수 없다는 조건이 주어진 경우, 그 속성값은 NULL이 될 수 없다는 제약 조건.
6. 키 무결성: 한 릴레이션에는 최소한 하나의 키가 존재해야 하는 제약조건.

</br>

## 키

> https://jerryjerryjerry.tistory.com/49

키는 데이터베이스에서 조건에 만족하는 관계의 행을 찾거나 순서대로 정렬할 때 다른 행과 구별할 수 있는 유리한 기준이 되는 속성의 집합이다.

키의 종류로는 슈퍼키, 후보키, 기본키, 대체키, 외래키 등이 있다.

1. **슈퍼키 (Super Key)**

   테이블에서 각 행을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합이다. 

   슈퍼키는 **유일성만 만족**하면 슈퍼키가 될 수 있다. 즉, 어떤 속성끼리 묶던 중복값이 안나오고 서로 구별만 할 수 있으면 된다.

   **:heavy_plus_sign: 유일성이란?**

   하나의 키로 특정 행을 바로 찾아낼 수 있는 고유한 데이터 속성을 말한다.

   예) 주민등록번호 (전국민이 모두 겹치지 않아 유일하고 고유한 구별 속성)

2. **후보키 (Candidate Key)**

   테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합이다.

   후보키는 기본키가 될 수 있는 후보들이며, **유일성과 최소성**을 동시에 만족해야한다.

3. **기본키 (Primary Key)**

   후보키들 중에서 하나를 선택한 키로 **최소성과 유일성**을 만족하는 속성이다.

   * 테이블에서 기본키는 오직 1개만 지정할 수 있다.

   * 기본키는 테이블 안에서 유일하게 각 행들을 구별할 수 있도록 쓰인다.

   * 기본키는 NULL 값을 절대 가질 수 없고, 중복된 값을 가질 수 없다.

     (=> 각 행들을 구별하려면 값이 없어선 안되고, 중복되어서도 안되기 때문)

4. **대체키 (Alternate Key)**

   후보키가 두 개 이상일 경우, 그 중에서 어느 하나를 기본키로 지정하고 남은 후보키들을 대체키라고 한다. (기본키로 선정되지 않은 후보키)

5. **외래키 (Foreign Key)**

   테이블이 다른 테이블의 데이터를 참조하여 테이블 간의 관계를 연결하는 것이다. 데이터를 좀 더 조회하기 쉽다.

   * 다른 테이블의 데이터를 참조할 때 없는 값을 참조할 수 없도록 제약을 주는 것이다.

   * 참조 될 테이블이 먼저 만들어지고, 참조하는 테이블에 값이 입력되어야 한다.

     -> 이때, 참조될 열의 값은 참조될 테이블에서 기본키로 설정되어 있어야 한다.

   * 외래키는 참조되는 테이블의 기본키와 동일한 속성을 가진다.

   * 부모 테이블을 먼저 삭제할 수 없다. 왜냐하면 부모 테이블을 참조하는데 부모 테이블이 삭제되면 자식 테이블은 참조하는 것이 없어지기 때문에 외래키 오류가 생긴다. 외래키 관계에서 부모 테이블을 삭제하려면 자식 테이블을 먼저 삭제한 후 부모 테이블을 삭제해야 한다.

## 파티셔닝

### 파티셔닝이란?

서비스의 크기가 점점 커지고 DB에 저장하는 데이터의 규모 또한 대용량화 되면서, 기존에 사용하는 DB 시스템의 용량(storage)의 한계와 성능(performance)의 저하를 가져오게 되었다.

즉, VLDB(Very Large DBMS)와 같이 하나의 DBMS에 너무 큰 table이 들어가면서 용량과 성능 측면에서 많은 이슈가 발생하게 되었고, 이런 이슈를 해결하기 위한 방법으로 table을 '**파티션(partition)**'이라는 작은 단위로 나누어 관리하는 '**파티셔닝(Partitioning)**'기법이 나타나게 되었다.

'파티셔닝'기법을 통해 소프트웨어적으로 데이터베이스를 분산 처리하여 성능이 저하되는 것을 방지하고 관리를 보다 수월하게 할 수 있게 되었다.

### 파티셔닝의 목적

* 가용성 (Availability)

  물리적인 파티셔닝으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상된다.

  각 분할 영역(partition별로)을 독립적으로 백업하고 복구할 수 있다.

  table의 partition단위로 Dist I/O을 분산하여 경합을 줄이기 때문에 `UPDATE`성능을 향상시킨다.

* 관리용이성 (Manageability)

  큰 Table들을 제거하여 관리를 쉽게 해준다.

* 성능 (Performance)

  특정 DML과 Query의 성능을 향상시킴. 주로 대용량 Data Write환경에서 효율적이다.

  특히, Full Scan에서 데이터 Access의 범위를 줄여 성능 향상을 가져온다.

  많은 `INSERT`가 있는 OLTP시스템에서 `INSERT`작업들을 분리된 파티션들로 분산시켜 경합을 줄인다. (OLTP: Online Transaction Processing. 트랜잭션 데이터를 관리하는 방식)

### 파티셔닝의 장점

* 관리적 측면 - partition 단위 백업, 추가, 삭제, 변경

  * 전체 데이터를 손실할 가능성이 줄어들어 데이터 가용성이 향상된다.
  * partition별로 백업 및 복구가 가능하다.
  * partition단위로 I/O분산이 가능하여 `UPDATE`성능을 향상시킨다.

* 성능적 측면 - partition 단위 조회 및 DML 수행

  * 데이터 전체 검색 시 필요한 부분만 탐색해 성능이 증가한다.

    즉, Full Scan에서 데이터 Access의 범위를 줄여 성능 향상을 가져온다.

  * 필요한 데이터만 빠르게 조회할 수 있기 때문에 쿼리 자체가 가볍다.

### 파티셔닝의 단점

* Table간의 `JOIN`에 대한 비용이 증가한다.
* 테이블과 인덱스를 별도로 파티션할 수 없다. 테이블과 인덱스를 같이 파티셔닝해야한다.

### DB 파티셔닝의 종류

1. **수평(horizontal) 파티셔닝**

   * 샤딩과 동일한 개념.

   * 스키마를 복제한 후 샤드키를 기준으로 데이터를 나누는 것을 말한다.
   * 즉, 스키마(Schema)가 같은 데이터를 두 개 이상의 테이블에 나누어 저장하는 것을 말한다.

   **특징**

   * 퍼포먼스, 가용성을 위해 Key 기반으로 여러 곳에 분산 저장한다.

     일반적으로 분산 저장 기술에서 파티셔닝은 수평 분할을 의미한다. 보통 수평 분할을 한다고 했을 때는 하나의 데이터베이스 안에서 이루어지는 경우를 지칭한다.

   **예시**

   * 고객의 데이터베이스를 CustomerID를 샤드키로 사용하여 샤딩한다고 가정.

     0 ~ 10000번 고객의 정보는 하나의 샤드에 저장하고 10001 ~ 20000번 고객의 정보는 다른 샤드에 저장한다.

     DBA는 데이터 엑세스 패턴과 저장 공간 이슈(로드의 적절한 분산, 데이터의 균등한 저장)를 고려하여 적절한 샤드키를 결정한다.

     같은 주민 데이터를 처리하기 위해 스키마가 같은 '서현동 주민 테이블'과 '정자동 주민 테이블'을 사용하는 것을 말한다.

     인덱스의 크기를 줄이고, 작업 동시성을 늘리기 위한 것이다.

   **장점**

   * 데이터의 개수를 기준으로 나누어 파티셔닝하기 때문에, 데이터의 개수가 작아지고 따라서 index의 개수도 작아지게 된다.
   * 자연스럽게 성능은 향상된다.

   **단점**

   * 서버 간의 연결과정이 많아진다.
   * 데이터를 찾는 과정이 기존보다 복잡하기 때문에 latency(지연시간)가 증가하게 된다.
   * 하나의 서버가 고장나게 되면 데이터의 무결성이 깨질 수 있다.

2. **수직(vertical) 파티셔닝**

   * 테이블의 일부 열을 빼내는 형태로 분할한다.
   * 모든 컬럼들 중 특정 컬럼들을 쪼개서 따로 저장하는 형태를 의미한다.
   * 스키마를 나누고 데이터가 따라 옮겨가는 것을 말한다.
   * 하나의 엔티티를 2개 이상으로 분리하는 작업이다.

   **특징**

   * 관계형 DB에서 3정규화와 같은 개념과 유사하다. 

     (하지만 수직 파티셔닝은 이미 정규화된 데이터를 분리하는 과정)

   **장점**

   * 자주 사용하는 컬럼 등을 분리시켜 성능을 향상시킬 수 있다.

     한 테이블을 `SELECT`하면 결국 모든 컬럼을 메모리에 올리게 되므로 필요없는 컬럼까지 올라가서 한 번에 읽을 수 있는 row가 줄어든다. 이는 I/O 측면에서 봤을 때 필요한 컬럼만 올리면 훨씬 많은 수의 row를 메모리에 올릴 수 있으니 성능상의 이점이 있다.

   * 같은 타입의 데이터가 저장되기 때문에 저장 시 데이터 압축률을 높일 수 있다.

### 파티셔닝의 분할 기준

데이터베이스 관리 시스템은 분할에 대해 각종 기준(분할 기법)을 제공하고 있다. 분할을 '분할 키(partitioning key)'를 사용한다.

1. 범위 분할 (range partitioning)

   분할 키 값이 범위 내에 있는지 여부로 구분한다.

   년도, 시간, 우편 번호를 분할 키로 수평 분할하는 경우이다.

2. 목록 분할 (list partitioning)

   분할 키는 특정 컬럼의 목록에 들어있는 값을 기준으로 한다.

   국가, 도시 등을 기준으로 사용하는 경우이다.

3. 해시 분할 (hash partitioning)

   해시 함수에 의해 결정된 키를 기준으로 한다. 

   데이터를 균등하게 배분할 수 있다.

   범위가 존재하지 않는 데이터를 가지고 있을 때 적합하다.

   각 파티션된 테이블에 어떤 값이 들어있는지는 알 수 없다.

4. 합성 분할 (composite partitioning)

   위의 기술들을 복합적으로 사용하는 방법이다.

   예를 들어 범위 분할 후 분할된 데이터를 해시 분할하는 경우 등이 있다.

</br>

## 샤딩

### 샤딩이란?

horizontal partitioning과 관련된 데이터베이스 설계 패턴이다. 한 테이블의 row들을 여러 개의 서로 다른 테이블, 즉 파티션으로 분리하는 것을 말한다.

(:heavy_plus_sign:vertical partitioning의 경우, 열 전체가 완전히 새로운 테이블로 분리되기 때문에, 테이블 내의 데이터들은 독립적이며 열과 행이 모두 달라진다.)

**shards**는 샤딩을 통해 나누어진 블록들을 말한다. 샤딩은 데이터를 작은 덩어리로 쪼개는 것이고, 이 작은 덩어리를 logical shards라고 부른다. logical shards는 분리된 physical shard, 즉 database node(데이터베이스의 인스턴스)에 뿌려진다.

shards들은 자립성이 강하기 때문에 같은 데이터나 컴퓨터 자원을 공유하지 않는다.

### 샤딩의 장점

* 수평적 확장(horizontal scaling)이 가능하다

  서버의 하드웨어(RAM, CPU 등)를 업그레이드하는 수직적 확장과 다르게, 존재하는 stack에 machine을 추가하는 방식으로 능력을 향상시킬 수 있다.

* 쿼리 반응 속도를 빠르게 한다.

  스캔 범위를 줄이기 때문이다.

* application을 신뢰할 수 있게 만든다.

  outage가 생겼을때, un-sharded 데이터베이스와 다르게 단일 shard에만 영향을 줄 확률이 높다. application이 일부라도 작동할 수 있또록 위험을 완화시켜준다.

### 샤딩의 단점

* 잘못 사용했을때 risk(데이터 손상, 유실 등)가 크다.
* 데이터가 한 쪽 shards에 쏠려 sharding이 무의미해질 수 있다.
* 한 번 쪼개게 되면, 다시 이전(un-sharded)구조로 돌리기 어렵다.
* 모든 데이터베이스 엔진에서 natively support되지 않는다.

### 샤딩의 구조

데이터가 맞는 shard에 들어가는 것이 중요하다. 그렇지 않으면 데이터를 잃거나 쿼리가 매우 느려진다. 보편적인 sharding방법은 다음과 같다.

1. **Key Based Sharding** (= hash based sharding)

   새로 쓰인 데이터로부터 value를 받아 해당 데이터가 어느 shard로 갈지 결정하는 hash 함수와 연결하는 방식이다.

   hash함수는 고객 이메일과 같은 데이터 조각을 input으로 받아, hash value라는 완전히 다른 형태의 value를 output으로 내보낸다. sharding의 관점에서 봤을 때, hash value는 들어오는 데이터가 저장될 shard를 결정하는 shard ID가 된다.

   <img src="https://user-images.githubusercontent.com/33208360/117808258-9e441580-b297-11eb-9fdb-0ba34988011d.png" alt="image" style="zoom:50%;" />

   **:heavy_plus_sign: shard key**

   올바른 shard에 일관성 있는 방식으로 들어갈 수 있도록 entry를 위치시키기 위해, hash함수에 들어가는 value들은 같은 column에서 나와야 한다.이 column을 shard key라고 부른다.

   * 각 행을 위한 고유 식별자를 생성한다는 측면에서 shard keys는 primary key(pk)와 비슷하다.
   * 넓게 보면, shard key는 정적이어야하고 시간에 따라 바뀌어서는 안된다. 그렇지 않으면 업데이트에 필요한 작업이 증가하고 퍼포먼스를 느리게 할 수 있다.

   **단점**

   * key based sharding이 많이 쓰이긴하지만, 데이터베이스에 서버를 동적으로 추가하거나 제거할 때 어려울 수 있다. 서버를 추가할 때 각각의 서버는 그에 상응하는 hash value가 있어야하고, 존재하는 많은 entry들은 맞는 hash value에 다시 매핑되고, 적합한 서버에 migrate되어야 한다. 데이터를 rebalancing하는 것을 시작한다면 새로운 hash 함수 뿐 아니라 예전 hash함수도 유효하지 않게 된다. 결과적으로 migration을 하는 동안 애플리케이션은 새로운 데이터를 쓰지 못하고 쉴 수 밖에 없다.

   **장점**

   * 이 전략의 가장 큰 장점은 hotspots를 방지하기 위해 데이터를 골고루 분배할 수 있고, 알고리즘적으로 분배하기 때문에 range나 directory와 다르게 모든 데이터가 어디에 위치하는지 말해주는 map을 가질 필요가 없다.

2. **Range Based Sharding**

   주어진 value의 범위를 기반으로 데이터를 쪼갠다. 데이터베이스에 어떤 브랜드의 카탈로그에 모든 상품에 대한 정보가 들어있다고 가정하여 이 방식을 적용한다면, 몇몇 개의 shard를 만들고 가격 범위에 따라서 상품정보를 저장할 수 있을 것이다.

   <img src="https://user-images.githubusercontent.com/33208360/117809249-ea438a00-b298-11eb-8f40-1aee6124288c.png" alt="image" style="zoom:50%;" />

   **장점**

   * 실행이 비교적 간단하다. 모든 shard들은 다른 데이터를 가지고 있고, original 데이터베이스 뿐 아니라 서로가 똑같은 스키마를 가지게 된다. application code는 그저 데이터가 어떤 범위인지 읽고 그에 상응하는 shard에 쓰면 된다.

   **단점**

   * 데이터베이스를 골고루 분배하지는 못하기 때문에 앞서 말한 데이터베이스 hotspots가 생길 수 있다. 특정 데이터가 다른 데이터에 비해 더 많이 찾아질 수 있기 때문에 읽는 횟수가 불균형할 수 있다.

3. **Directory Based Sharding**

   이 sharding을 실행하기 위해서는 반드시 어떤 shard가 어떤 데이터를 가지고 있는지를 추적할 수 있는 lookup table을 만들고 유지해야 한다.

   **:heavy_plus_sign: lookup table**

   특정 데이터를 찾을 수 있는 정적인 정보를 가지고 있는 테이블.

   <img src="https://user-images.githubusercontent.com/33208360/117809881-aef58b00-b299-11eb-99f5-4bc9d33daf8b.png" alt="image" style="zoom:50%;" />

   -> Delevery zone열은 shard key로 정의된다. shard key로부터 온 데이터는 각각의 행이 어떤 shard에 쓰여져야하는지를 lookup 테이블과 함께 쓰여진다. range based sharding과 비슷해보이지만, 범위를 기준으로 shard key의 데이터를 내려주는 것과 다르게 각 키들은 자신만의 특별한 shard에 들어가게 된다.

   **사용 적합한 경우**

   * shard key가 낮은 cardinality를 가질 때 적합하다. hash 함수를 거치지 않기 때문에 key based sharding과 다르다. 그저 lookup table에서 key를 보고 어디에 데이터를 쓸지 결정하는 것 뿐이다.

   **장점**

   * 유연성(flexibility)

     range based sharding은 범위에 국한되고, key based sharding은 만들고 난 뒤 바꾸기 매우 어려운 hash 함수에 국한된다. 반면 directory based sharding은 데이터를 쪼개기 위한 entry들은 어떤 시스템이나 알고리즘에 상관없이 entry를 할당할 수 있도록 해준다. 동적으로 shard를 추가하는 것도 비교적 쉽다.

   **단점**

   * 쿼리나 write하기 전에 lookup table에 연결이 필요하기 때문에, application 성능에 안좋은 영향을 줄 수 있다.
   * lookup table이 손상되면 데이터를 새로 쓰거나 존재하는 데이터에 접근하는 것에 영향을 줄 수 있기 때문에 lookup table은 실패지점이 될 수 있다.

</br>

## ORM

### 영속성(Persistence)

데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성을 말한다. 영속성을 갖지 않는 데이터는 단지 메모리에서만 존재하기 때문에 프로그램을 종료하면 모두 잃어버리게 된다.

**Object Persistence(영구적인 객체)**

* 메모리 상의 데이터를 파일 시스템, 관계형 데이터베이스 혹은 객체 데이터베이스 등을 활용하여 영구적으로 저장하여 영속성을 부여한다.

  <img src="https://user-images.githubusercontent.com/33208360/117813606-4066fc00-b29e-11eb-838d-0f839642a683.png" alt="image" style="zoom: 50%;" />

* 데이터를 데이터베이스에 저장하는 3가지 방법

  1) JDBC (java에서 사용)

  2) Spring JDBC (예: JdbcTemplate)

  3) Persistence Framework (예: Hibernate, Mybatis 등)

**Persistence Layer**

* 프로그램의 아키텍처에서 데이터에 영속성을 부여해주는 계층을 말한다.

* JDBC를 이용하여 직접 구현할 수 있지만 Persistence framework를 이용한 개발이 많이 이루어진다.

  <img src="https://user-images.githubusercontent.com/33208360/117813858-8e7bff80-b29e-11eb-8106-1c9ae7edd4a7.png" alt="image" style="zoom:33%;" />

**Persistence Framework**

* JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스와 연동되는 시스템을 빠르게 개발할 수 있으며 안정적인 구동을 보장한다.
* SQL Mapper와 ORM으로 나눌 수 있다.

### ORM이란?

Object Relational Mapping (객체-관계 매핑)

* 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것을 말한다.
  * 객체 지향 프로그래밍은 **클래스**를 사용하고, 관계형 데이터베이스는 **테이블**을 사용한다.
  * 객체 모델과 관계형 모델 간에 불일치가 존재한다.
  * ORM을 통해 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결한다.

* 데이터베이스의 데이터 < ----> Object 필드
  * 객체를 통해 간접적으로 데이터베이스 데이터를 다룬다.
* Persistent API라고도 할 수 있다.
  * 예) JPA, Hibernate 등

### ORM의 장점

* 객체 지향적인 코드로 인해 더 직관적이고 **비즈니스 로직에 더 집중**할 수 있게 도와준다.
  * 각종 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성을 올려준다.
  * SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.
* **재사용 및 유지보수**의 편리성이 증가한다.
  * ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용할 수 있기 때문에 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다.
  * 매핑정보가 명확하여 ERD를 보는 것에 대한 의존도를 낮출 수 있다.
* **DBMS에 대한 종속성이 줄어든다.**
  * 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하기 때문에 RDBMS의 데이터 구조와 Java의 객체지향 모델 사이의 간격을 좁힐 수 있다.
  * 대부분의 ORM 솔루션은 DB에 종속적이지 않다. (구현 방법 뿐 아니라 많은 솔루션에서 자료형 타입까지 종속적이지 않음)

### ORM의 단점

* ORM으로만 서비스를 구현하기가 어렵다.
  * 사용하기 편하지만 설계는 매우 신중하게 해야한다.
  * 프로젝트의 복잡성이 커질 경우, 난이도 또한 올라갈 수 있다.
* 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.
  * 이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야 하며, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있다.

</br>

## JDBC

### JDBC란?

JDBC(Java DataBase Connectivity)는 DB에 접근할 수 있도록 Java에서 제공하는 API이다.

* JDBC는 관계형 데이터베이스에 사용되는 SQL문을 실행하기 위해 Java로 작성된 클래스와 인터페이스로 구성되어 있다.
* 특정 데이터베이스나 특정 데이터베이스 메커니즘에 구애 받지않는 독립적인 인터페이스를 통해 다양한 데이터베이스에 접근하는 코드를 구현할 수 있도록 제공하는 자바 클래스의 표준 집합이다.
* JDBC 클래스는 자바 패키지 `java.sql`과 `javax.sql`에 포함되어 있다.

### JDBC를 이용한 DB 접근

1. JDBC driver 로딩
2. Connection 맺기
3. SQL 실행
4. 자원 반환

## SQL vs NoSQL
> https://siyoon210.tistory.com/130

> https://mjmjmj98.tistory.com/43
### SQL(관계형 데이터베이스)
SQL은 '구조화된 쿼리 언어(Structured Query Launguage)'의 약자로, 데이터베이스 자체를 나타내는 것이 아니라 특정 유형의 데이터베이스와 상호 작용 하는데 사용하는 쿼리 언어이다. SQL을 사용하면 관계형 데이터베이스 관리 시스팀(RDBMS)에서 데이터를 저장, 수정, 삭제 및 검색 할 수 있다.

**SQL의 두 가지 특징**
1. 데이터는 정해진(엄격한) 데이터 스키마(=structure)를 따라 데이터베이스 테이블에 저장된다.
2. 데이터는 관계를 통해서 연결된 여러 개의 테이블에 분산된다.

#### 1. 엄격한 스키마
+ 데이터는 테이블(table)에 레코드(record)로 저장되며, 각 테이블에는 명확하게 정의된 구조(structure)가 있다.
   + 구조란 어떤 데이터가 테이블에 들어가고 어떤 데이터가 그렇지 않을지 정의하는 필드(field) 집합
+ 구조(structure)는 필드의 이름과 데이터 유형으로 정의된다.
+ 관계형 데이터베이스에서 스키마를 준수하지 않는 레코드는 추가할 수 없다.

#### 2. 관계
+ 데이터들을 여러 개의 테이블에 나누어서 데이터들의 중복을 피할 수 있다.
+ 각 테이블 간의 관계 지정을 통해 테이블에 접근할 수 있고, 따라서 중복 없이 해당 데이터만을 다룰 수 있다.

   <img src="https://user-images.githubusercontent.com/33089715/120440475-8eaf7c80-c3be-11eb-929f-086ebd00cadd.png" width = "300">

#### 장점
+ 명확하게 정의 된 스키마, 데이터 무결성 보장
+ 관계는 각 데이터를 중복 없이 한번만 저장된다.
#### 단점
+ 상대적으로 덜 유연하다. 데이터 스키마는 사전에 계획되고 알려져야 한다.(나중에 수정하기 번거롭거나 불가능)
+ 관계를 맺고 있기 때문에, JOIN 문이 많은 매우 복잡한 쿼리가 만들어 질 수 있다.
+ 수평적 확장이 어렵고, 대체로 수직적 확장만 가능하다. 즉 어떤 시점에서 (처리할 수 있는 처리량과 관련하여) 성장 한계에 직면한다.
#### 정리
+ 관계를 맺고 있는 데이터가 자주 변경(수정)되는 애플리케이션일 경우 사용
+ 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우 사용

### NoSQL(Non-Relational, 비관계형 데이터베이스)
NoSQL은 기본적으로 SQL(관계형 데이터베이스)와 반대되는 접근 방식을 따르기 때문에 지어진 이름이다.

**NoSQL의 특징**
1. 스키마 없음
2. 관계 없음

#### 1. 스키마 없음
+ 레코드를 문서(documents)라고 하고 테이블의 개념을 collection이라 한다.
+ NoSQL에서는 데이터의 구조가 같을 필요가 없기 때문에 다른 구조의 문서를 컬렉션에 추가할 수 있다.

   <img src="https://user-images.githubusercontent.com/33089715/120441382-73913c80-c3bf-11eb-8108-1bd9e73a489f.png" width = "300">

#### 2. 비관계형
+ NoSQL에서는 하나의 컬렉션에 관련 데이터를 모두 작성한다. 따라서 중복 데이터가 생기게 된다.
+ 여러 테이블/컬렉션에 조인(join) 할 필요 없이 이미 필요한 모든 것을 갖춘 문서를 작성하게 된다.
+ NoSQL 데이터베이스에는 조인이라는 개념이 존재하지 않는다.
+ 데이터가 중복된다는 점에 불안정한 측면이 있지만 조인을 사용할 필요가 없다는 장점이 있다. 따라서 자주 변경되지 않는 데이터일 때 사용하면 좋다.

#### 장점
+ 스키마가 없기 때문에, 훨씬 더 유연하다. 즉, 언제든지 저장된 데이터를 조정하고 새로운 "필드"를 추가할 수 있다.
+ 데이터는 애플리케이션이 필요로 하는 형식으로 저장된다. 이렇게 하면 데이터를 읽어오는 속도가 빨라진다.
+ 수직 및 수평 확장이 가능하므로 데이터베이스가 애플리케이션에서 발생시키는 모든 읽기/쓰기 요청을 처리할 수 있다.

#### 단점 
+ 유연성 때문에, 데이터 구조를 결정하지 못하고 미루게 될 수 있다.
+ 데이터 중복은 여러 컬렉션과 문서가 여러 개 변경된 경우 업데이트를 해야한다.
+ 데이터가 여러 컬렉션에 중복되어 있기 때문에, 수정(Update)을 해야하는 경우 모든 컬렉션에서 수행해야 함을 의미한다.

#### 정리
+ 정확한 데이터 구조를 알 수 없거나 변경/확장될 수 있는 경우 사용
+ 읽기(Read)처리를 자주하지만, 데이터를 자주 변경(Update)하지 않는 경우 사용
+ 데이터를 수평으로 확장해야 하는 경우(즉, 막대한 양의 데이터를 다뤄야 하는 경우)